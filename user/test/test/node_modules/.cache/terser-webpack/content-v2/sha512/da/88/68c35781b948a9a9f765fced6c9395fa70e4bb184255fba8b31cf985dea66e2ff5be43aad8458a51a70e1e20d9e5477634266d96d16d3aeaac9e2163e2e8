{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{cxbk:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.d(__webpack_exports__,\"a\",function(){return environment});const environment={production:!0,google_map_key:\"AIzaSyCb9lhLYxUnRjSp1oIGl6aAsXLODc3o-f4\"}},pxUr:function(module,__webpack_exports__,__webpack_require__){\"use strict\";function __awaiter(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){var value;result.done?resolve(result.value):(value=result.value,value instanceof P?value:new P(function(resolve){resolve(value)})).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})}__webpack_require__.d(__webpack_exports__,\"a\",function(){return agm_core_AgmCoreModule}),__webpack_require__.d(__webpack_exports__,\"b\",function(){return agm_core_AgmMap}),__webpack_require__.d(__webpack_exports__,\"c\",function(){return agm_core_AgmMarker}),__webpack_require__.d(__webpack_exports__,\"d\",function(){return agm_core_GoogleMapsAPIWrapper});var core=__webpack_require__(\"fXoL\"),Observable=__webpack_require__(\"HDdC\"),BehaviorSubject=__webpack_require__(\"2Vo4\"),from=__webpack_require__(\"Cfvw\"),timer=__webpack_require__(\"PqYM\"),Subject=__webpack_require__(\"XNiG\"),AsyncAction=__webpack_require__(\"3N8a\");class QueueAction_QueueAction extends AsyncAction.a{constructor(scheduler,work){super(scheduler,work),this.scheduler=scheduler,this.work=work}schedule(state,delay=0){return delay>0?super.schedule(state,delay):(this.delay=delay,this.state=state,this.scheduler.flush(this),this)}execute(state,delay){return delay>0||this.closed?super.execute(state,delay):this._execute(state,delay)}requestAsyncId(scheduler,id,delay=0){return null!==delay&&delay>0||null===delay&&this.delay>0?super.requestAsyncId(scheduler,id,delay):scheduler.flush(this)}}var AsyncScheduler=__webpack_require__(\"IjjT\");class QueueScheduler_QueueScheduler extends AsyncScheduler.a{}const queue=new QueueScheduler_QueueScheduler(QueueAction_QueueAction);var Subscription=__webpack_require__(\"quSY\"),Subscriber=__webpack_require__(\"7o/Q\"),empty=__webpack_require__(\"EY2u\"),of=__webpack_require__(\"LRne\");let Notification_Notification=(()=>{class Notification{constructor(kind,value,error){this.kind=kind,this.value=value,this.error=error,this.hasValue=\"N\"===kind}observe(observer){switch(this.kind){case\"N\":return observer.next&&observer.next(this.value);case\"E\":return observer.error&&observer.error(this.error);case\"C\":return observer.complete&&observer.complete()}}do(next,error,complete){switch(this.kind){case\"N\":return next&&next(this.value);case\"E\":return error&&error(this.error);case\"C\":return complete&&complete()}}accept(nextOrObserver,error,complete){return nextOrObserver&&\"function\"==typeof nextOrObserver.next?this.observe(nextOrObserver):this.do(nextOrObserver,error,complete)}toObservable(){switch(this.kind){case\"N\":return Object(of.a)(this.value);case\"E\":return error=this.error,new Observable.a(subscriber=>subscriber.error(error));case\"C\":return Object(empty.b)()}var error;throw new Error(\"unexpected notification kind value\")}static createNext(value){return void 0!==value?new Notification(\"N\",value):Notification.undefinedValueNotification}static createError(err){return new Notification(\"E\",void 0,err)}static createComplete(){return Notification.completeNotification}}return Notification.completeNotification=new Notification(\"C\"),Notification.undefinedValueNotification=new Notification(\"N\",void 0),Notification})();class observeOn_ObserveOnSubscriber extends Subscriber.a{constructor(destination,scheduler,delay=0){super(destination),this.scheduler=scheduler,this.delay=delay}static dispatch(arg){const{notification:notification,destination:destination}=arg;notification.observe(destination),this.unsubscribe()}scheduleMessage(notification){this.destination.add(this.scheduler.schedule(observeOn_ObserveOnSubscriber.dispatch,this.delay,new ObserveOnMessage(notification,this.destination)))}_next(value){this.scheduleMessage(Notification_Notification.createNext(value))}_error(err){this.scheduleMessage(Notification_Notification.createError(err)),this.unsubscribe()}_complete(){this.scheduleMessage(Notification_Notification.createComplete()),this.unsubscribe()}}class ObserveOnMessage{constructor(notification,destination){this.notification=notification,this.destination=destination}}var ObjectUnsubscribedError=__webpack_require__(\"9ppp\"),SubjectSubscription=__webpack_require__(\"Ylt2\");class ReplaySubject_ReplaySubject extends Subject.a{constructor(bufferSize=Number.POSITIVE_INFINITY,windowTime=Number.POSITIVE_INFINITY,scheduler){super(),this.scheduler=scheduler,this._events=[],this._infiniteTimeWindow=!1,this._bufferSize=bufferSize<1?1:bufferSize,this._windowTime=windowTime<1?1:windowTime,windowTime===Number.POSITIVE_INFINITY?(this._infiniteTimeWindow=!0,this.next=this.nextInfiniteTimeWindow):this.next=this.nextTimeWindow}nextInfiniteTimeWindow(value){const _events=this._events;_events.push(value),_events.length>this._bufferSize&&_events.shift(),super.next(value)}nextTimeWindow(value){this._events.push(new ReplayEvent(this._getNow(),value)),this._trimBufferThenGetEvents(),super.next(value)}_subscribe(subscriber){const _infiniteTimeWindow=this._infiniteTimeWindow,_events=_infiniteTimeWindow?this._events:this._trimBufferThenGetEvents(),scheduler=this.scheduler,len=_events.length;let subscription;if(this.closed)throw new ObjectUnsubscribedError.a;if(this.isStopped||this.hasError?subscription=Subscription.a.EMPTY:(this.observers.push(subscriber),subscription=new SubjectSubscription.a(this,subscriber)),scheduler&&subscriber.add(subscriber=new observeOn_ObserveOnSubscriber(subscriber,scheduler)),_infiniteTimeWindow)for(let i=0;i<len&&!subscriber.closed;i++)subscriber.next(_events[i]);else for(let i=0;i<len&&!subscriber.closed;i++)subscriber.next(_events[i].value);return this.hasError?subscriber.error(this.thrownError):this.isStopped&&subscriber.complete(),subscription}_getNow(){return(this.scheduler||queue).now()}_trimBufferThenGetEvents(){const now=this._getNow(),_bufferSize=this._bufferSize,_windowTime=this._windowTime,_events=this._events,eventsCount=_events.length;let spliceCount=0;for(;spliceCount<eventsCount&&!(now-_events[spliceCount].time<_windowTime);)spliceCount++;return eventsCount>_bufferSize&&(spliceCount=Math.max(spliceCount,eventsCount-_bufferSize)),spliceCount>0&&_events.splice(0,spliceCount),_events}}class ReplayEvent{constructor(time,value){this.time=time,this.value=value}}var map=__webpack_require__(\"lJxs\"),isArray=(__webpack_require__(\"8Qeq\"),__webpack_require__(\"DH7j\"));__webpack_require__(\"z+Ro\");var isFunction=__webpack_require__(\"n6bG\");function fromEventPattern(addHandler,removeHandler,resultSelector){return resultSelector?fromEventPattern(addHandler,removeHandler).pipe(Object(map.a)(args=>Object(isArray.a)(args)?resultSelector(...args):resultSelector(args))):new Observable.a(subscriber=>{const handler=(...e)=>subscriber.next(1===e.length?e[0]:e);let retValue;try{retValue=addHandler(handler)}catch(err){return void subscriber.error(err)}if(Object(isFunction.a)(removeHandler))return()=>removeHandler(handler,retValue)})}var merge=__webpack_require__(\"VRyK\"),mergeMap=__webpack_require__(\"5+tZ\"),OuterSubscriber=__webpack_require__(\"l7GE\"),subscribeToResult=__webpack_require__(\"ZUHj\");class sample_SampleOperator{constructor(notifier){this.notifier=notifier}call(subscriber,source){const sampleSubscriber=new sample_SampleSubscriber(subscriber),subscription=source.subscribe(sampleSubscriber);return subscription.add(Object(subscribeToResult.a)(sampleSubscriber,this.notifier)),subscription}}class sample_SampleSubscriber extends OuterSubscriber.a{constructor(){super(...arguments),this.hasValue=!1}_next(value){this.value=value,this.hasValue=!0}notifyNext(outerValue,innerValue,outerIndex,innerIndex,innerSub){this.emitValue()}notifyComplete(){this.emitValue()}emitValue(){this.hasValue&&(this.hasValue=!1,this.destination.next(this.value))}}var switchMap=__webpack_require__(\"eIep\");__webpack_require__(\"oB13\");var startWith=__webpack_require__(\"JX91\");class SkipOperator{constructor(total){this.total=total}call(subscriber,source){return source.subscribe(new skip_SkipSubscriber(subscriber,this.total))}}class skip_SkipSubscriber extends Subscriber.a{constructor(destination,total){super(destination),this.total=total,this.count=0}_next(x){++this.count>this.total&&this.destination.next(x)}}__webpack_require__(\"/uUt\"),__webpack_require__(\"1G5W\");var common=__webpack_require__(\"ofXK\");const _c0=[\"*\"];let agm_core_MapsAPILoader=(()=>{class MapsAPILoader{}return MapsAPILoader.ɵfac=function(t){return new(t||MapsAPILoader)},MapsAPILoader.ɵprov=core[\"ɵɵdefineInjectable\"]({token:MapsAPILoader,factory:MapsAPILoader.ɵfac}),MapsAPILoader})(),agm_core_GoogleMapsAPIWrapper=(()=>{class GoogleMapsAPIWrapper{constructor(_loader,_zone){this._loader=_loader,this._zone=_zone,this._map=new Promise(resolve=>{this._mapResolver=resolve})}createMap(el,mapOptions){return this._zone.runOutsideAngular(()=>this._loader.load().then(()=>{const map=new google.maps.Map(el,mapOptions);this._mapResolver(map)}))}setMapOptions(options){return this._zone.runOutsideAngular(()=>{this._map.then(m=>{m.setOptions(options)})})}createMarker(options={},addToMap=!0){return this._zone.runOutsideAngular(()=>this._map.then(map=>(addToMap&&(options.map=map),new google.maps.Marker(options))))}createInfoWindow(options){return this._zone.runOutsideAngular(()=>this._map.then(()=>new google.maps.InfoWindow(options)))}createCircle(options){return this._zone.runOutsideAngular(()=>this._map.then(map=>(options.map=map,new google.maps.Circle(options))))}createRectangle(options){return this._zone.runOutsideAngular(()=>this._map.then(map=>(options.map=map,new google.maps.Rectangle(options))))}createPolyline(options){return this._zone.runOutsideAngular(()=>this.getNativeMap().then(map=>{const line=new google.maps.Polyline(options);return line.setMap(map),line}))}createPolygon(options){return this._zone.runOutsideAngular(()=>this.getNativeMap().then(map=>{const polygon=new google.maps.Polygon(options);return polygon.setMap(map),polygon}))}createDataLayer(options){return this._zone.runOutsideAngular(()=>this._map.then(m=>{const data=new google.maps.Data(options);return data.setMap(m),data}))}createTransitLayer(){return this._zone.runOutsideAngular(()=>this._map.then(map=>{const newLayer=new google.maps.TransitLayer;return newLayer.setMap(map),newLayer}))}createBicyclingLayer(){return this._zone.runOutsideAngular(()=>this._map.then(map=>{const newLayer=new google.maps.BicyclingLayer;return newLayer.setMap(map),newLayer}))}containsLocation(latLng,polygon){return this._map.then(()=>google.maps.geometry.poly.containsLocation(latLng,polygon))}subscribeToMapEvent(eventName){return new Observable.a(observer=>{this._map.then(m=>m.addListener(eventName,()=>this._zone.run(()=>observer.next(arguments[0]))))})}clearInstanceListeners(){return this._zone.runOutsideAngular(()=>{this._map.then(map=>{google.maps.event.clearInstanceListeners(map)})})}setCenter(latLng){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.setCenter(latLng)))}getZoom(){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.getZoom()))}getBounds(){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.getBounds()))}getMapTypeId(){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.getMapTypeId()))}setZoom(zoom){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.setZoom(zoom)))}getCenter(){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.getCenter()))}panTo(latLng){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.panTo(latLng)))}panBy(x,y){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.panBy(x,y)))}fitBounds(latLng,padding){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.fitBounds(latLng,padding)))}panToBounds(latLng,padding){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.panToBounds(latLng,padding)))}getNativeMap(){return this._map}triggerMapEvent(eventName){return this._map.then(m=>google.maps.event.trigger(m,eventName))}}return GoogleMapsAPIWrapper.ɵfac=function(t){return new(t||GoogleMapsAPIWrapper)(core[\"ɵɵinject\"](agm_core_MapsAPILoader),core[\"ɵɵinject\"](core.NgZone))},GoogleMapsAPIWrapper.ɵprov=core[\"ɵɵdefineInjectable\"]({token:GoogleMapsAPIWrapper,factory:GoogleMapsAPIWrapper.ɵfac}),GoogleMapsAPIWrapper})(),agm_core_CircleManager=(()=>{class CircleManager{constructor(_apiWrapper,_zone){this._apiWrapper=_apiWrapper,this._zone=_zone,this._circles=new Map}addCircle(circle){this._apiWrapper.getNativeMap().then(()=>this._circles.set(circle,this._apiWrapper.createCircle({center:{lat:circle.latitude,lng:circle.longitude},clickable:circle.clickable,draggable:circle.draggable,editable:circle.editable,fillColor:circle.fillColor,fillOpacity:circle.fillOpacity,radius:circle.radius,strokeColor:circle.strokeColor,strokeOpacity:circle.strokeOpacity,strokePosition:google.maps.StrokePosition[circle.strokePosition],strokeWeight:circle.strokeWeight,visible:circle.visible,zIndex:circle.zIndex})))}removeCircle(circle){return this._circles.get(circle).then(c=>{c.setMap(null),this._circles.delete(circle)})}setOptions(circle,options){return __awaiter(this,void 0,void 0,function*(){return this._circles.get(circle).then(c=>{options.strokePosition=google.maps.StrokePosition[options.strokePosition],c.setOptions(options)})})}getBounds(circle){return this._circles.get(circle).then(c=>c.getBounds())}getCenter(circle){return this._circles.get(circle).then(c=>c.getCenter())}getRadius(circle){return this._circles.get(circle).then(c=>c.getRadius())}setCenter(circle){return this._circles.get(circle).then(c=>c.setCenter({lat:circle.latitude,lng:circle.longitude}))}setEditable(circle){return this._circles.get(circle).then(c=>c.setEditable(circle.editable))}setDraggable(circle){return this._circles.get(circle).then(c=>c.setDraggable(circle.draggable))}setVisible(circle){return this._circles.get(circle).then(c=>c.setVisible(circle.visible))}setRadius(circle){return this._circles.get(circle).then(c=>c.setRadius(circle.radius))}getNativeCircle(circle){return this._circles.get(circle)}createEventObservable(eventName,circle){return new Observable.a(observer=>{let listener=null;return this._circles.get(circle).then(c=>{listener=c.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))}),()=>{null!==listener&&listener.remove()}})}}return CircleManager.ɵfac=function(t){return new(t||CircleManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper),core[\"ɵɵinject\"](core.NgZone))},CircleManager.ɵprov=core[\"ɵɵdefineInjectable\"]({token:CircleManager,factory:CircleManager.ɵfac}),CircleManager})(),agm_core_DataLayerManager=(()=>{class DataLayerManager{constructor(_wrapper,_zone){this._wrapper=_wrapper,this._zone=_zone,this._layers=new Map}addDataLayer(layer){const newLayer=this._wrapper.createDataLayer({style:layer.style}).then(d=>(layer.geoJson&&this.getDataFeatures(d,layer.geoJson).then(features=>d.features=features),d));this._layers.set(layer,newLayer)}deleteDataLayer(layer){this._layers.get(layer).then(l=>{l.setMap(null),this._layers.delete(layer)})}updateGeoJson(layer,geoJson){this._layers.get(layer).then(l=>{l.forEach(feature=>{l.remove(feature);const index=l.features.indexOf(feature,0);index>-1&&l.features.splice(index,1)}),this.getDataFeatures(l,geoJson).then(features=>l.features=features)})}setDataOptions(layer,options){this._layers.get(layer).then(l=>{l.setControlPosition(options.controlPosition),l.setControls(options.controls),l.setDrawingMode(options.drawingMode),l.setStyle(options.style)})}createEventObservable(eventName,layer){return new Observable.a(observer=>{this._layers.get(layer).then(d=>{d.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}getDataFeatures(d,geoJson){return new Promise((resolve,reject)=>{if(\"object\"==typeof geoJson)try{resolve(d.addGeoJson(geoJson))}catch(e){reject(e)}else\"string\"==typeof geoJson?d.loadGeoJson(geoJson,null,resolve):reject(\"Impossible to extract features from geoJson: wrong argument type\")})}}return DataLayerManager.ɵfac=function(t){return new(t||DataLayerManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper),core[\"ɵɵinject\"](core.NgZone))},DataLayerManager.ɵprov=core[\"ɵɵdefineInjectable\"]({token:DataLayerManager,factory:DataLayerManager.ɵfac}),DataLayerManager})();class FitBoundsAccessor{}let agm_core_FitBoundsService=(()=>{class FitBoundsService{constructor(loader){var notifier;this._boundsChangeSampleTime$=new BehaviorSubject.a(200),this._includeInBounds$=new BehaviorSubject.a(new Map),this.bounds$=Object(from.a)(loader.load()).pipe(Object(mergeMap.a)(()=>this._includeInBounds$),(notifier=this._boundsChangeSampleTime$.pipe(Object(switchMap.a)(time=>Object(timer.a)(0,time))),source=>source.lift(new sample_SampleOperator(notifier))),Object(map.a)(includeInBounds=>this._generateBounds(includeInBounds)),function(configOrBufferSize,windowTime,scheduler){let config;return config={bufferSize:1,windowTime:void 0,refCount:!1,scheduler:void 0},source=>source.lift(function({bufferSize:bufferSize=Number.POSITIVE_INFINITY,windowTime:windowTime=Number.POSITIVE_INFINITY,refCount:useRefCount,scheduler:scheduler}){let subject,subscription,refCount=0,hasError=!1,isComplete=!1;return function(source){refCount++,subject&&!hasError||(hasError=!1,subject=new ReplaySubject_ReplaySubject(bufferSize,windowTime,scheduler),subscription=source.subscribe({next(value){subject.next(value)},error(err){hasError=!0,subject.error(err)},complete(){isComplete=!0,subscription=void 0,subject.complete()}}));const innerSub=subject.subscribe(this);this.add(()=>{refCount--,innerSub.unsubscribe(),subscription&&!isComplete&&useRefCount&&0===refCount&&(subscription.unsubscribe(),subscription=void 0,subject=void 0)})}}(config))}())}_generateBounds(includeInBounds){const bounds=new google.maps.LatLngBounds;return includeInBounds.forEach(b=>bounds.extend(b)),bounds}addToBounds(latLng){const id=this._createIdentifier(latLng);if(this._includeInBounds$.value.has(id))return;const boundsMap=this._includeInBounds$.value;boundsMap.set(id,latLng),this._includeInBounds$.next(boundsMap)}removeFromBounds(latLng){const boundsMap=this._includeInBounds$.value;boundsMap.delete(this._createIdentifier(latLng)),this._includeInBounds$.next(boundsMap)}changeFitBoundsChangeSampleTime(timeMs){this._boundsChangeSampleTime$.next(timeMs)}getBounds$(){return this.bounds$}_createIdentifier(latLng){return`${latLng.lat}+${latLng.lng}`}}return FitBoundsService.ɵfac=function(t){return new(t||FitBoundsService)(core[\"ɵɵinject\"](agm_core_MapsAPILoader))},FitBoundsService.ɵprov=core[\"ɵɵdefineInjectable\"]({token:FitBoundsService,factory:FitBoundsService.ɵfac}),FitBoundsService})();class WindowRef{getNativeWindow(){return window}}class DocumentRef{getNativeDocument(){return document}}const BROWSER_GLOBALS_PROVIDERS=[WindowRef,DocumentRef];var GoogleMapsScriptProtocol=function(GoogleMapsScriptProtocol){return GoogleMapsScriptProtocol[GoogleMapsScriptProtocol.HTTP=1]=\"HTTP\",GoogleMapsScriptProtocol[GoogleMapsScriptProtocol.HTTPS=2]=\"HTTPS\",GoogleMapsScriptProtocol[GoogleMapsScriptProtocol.AUTO=3]=\"AUTO\",GoogleMapsScriptProtocol}({});const LAZY_MAPS_API_CONFIG=new core.InjectionToken(\"angular-google-maps LAZY_MAPS_API_CONFIG\");let agm_core_LazyMapsAPILoader=(()=>{class LazyMapsAPILoader extends agm_core_MapsAPILoader{constructor(config=null,w,d,localeId){super(),this.localeId=localeId,this._SCRIPT_ID=\"agmGoogleMapsApiScript\",this.callbackName=\"agmLazyMapsAPILoader\",this._config=config||{},this._windowRef=w,this._documentRef=d}load(){const window=this._windowRef.getNativeWindow();if(window.google&&window.google.maps)return Promise.resolve();if(this._scriptLoadingPromise)return this._scriptLoadingPromise;const scriptOnPage=this._documentRef.getNativeDocument().getElementById(this._SCRIPT_ID);if(scriptOnPage)return this._assignScriptLoadingPromise(scriptOnPage),this._scriptLoadingPromise;const script=this._documentRef.getNativeDocument().createElement(\"script\");return script.type=\"text/javascript\",script.async=!0,script.defer=!0,script.id=this._SCRIPT_ID,script.src=this._getScriptSrc(this.callbackName),this._assignScriptLoadingPromise(script),this._documentRef.getNativeDocument().body.appendChild(script),this._scriptLoadingPromise}_assignScriptLoadingPromise(scriptElem){this._scriptLoadingPromise=new Promise((resolve,reject)=>{this._windowRef.getNativeWindow()[this.callbackName]=()=>{resolve()},scriptElem.onerror=error=>{reject(error)}})}_getScriptSrc(callbackName){let protocol;switch(this._config&&this._config.protocol||GoogleMapsScriptProtocol.HTTPS){case GoogleMapsScriptProtocol.AUTO:protocol=\"\";break;case GoogleMapsScriptProtocol.HTTP:protocol=\"http:\";break;case GoogleMapsScriptProtocol.HTTPS:protocol=\"https:\"}const queryParams={v:this._config.apiVersion||\"quarterly\",callback:callbackName,key:this._config.apiKey,client:this._config.clientId,channel:this._config.channel,libraries:this._config.libraries,region:this._config.region,language:this._config.language||(\"en-US\"!==this.localeId?this.localeId:null)};return`${protocol}//${this._config.hostAndPath||\"maps.googleapis.com/maps/api/js\"}?${Object.keys(queryParams).filter(k=>null!=queryParams[k]).filter(k=>!Array.isArray(queryParams[k])||Array.isArray(queryParams[k])&&queryParams[k].length>0).map(k=>{const i=queryParams[k];return Array.isArray(i)?{key:k,value:i.join(\",\")}:{key:k,value:queryParams[k]}}).map(entry=>`${entry.key}=${entry.value}`).join(\"&\")}`}}return LazyMapsAPILoader.ɵfac=function(t){return new(t||LazyMapsAPILoader)(core[\"ɵɵinject\"](LAZY_MAPS_API_CONFIG,8),core[\"ɵɵinject\"](WindowRef),core[\"ɵɵinject\"](DocumentRef),core[\"ɵɵinject\"](core.LOCALE_ID))},LazyMapsAPILoader.ɵprov=core[\"ɵɵdefineInjectable\"]({token:LazyMapsAPILoader,factory:LazyMapsAPILoader.ɵfac}),LazyMapsAPILoader})(),agm_core_MarkerManager=(()=>{class MarkerManager{constructor(_mapsWrapper,_zone){this._mapsWrapper=_mapsWrapper,this._zone=_zone,this._markers=new Map}convertAnimation(uiAnim){return __awaiter(this,void 0,void 0,function*(){return null===uiAnim?null:this._mapsWrapper.getNativeMap().then(()=>google.maps.Animation[uiAnim])})}deleteMarker(markerDirective){const markerPromise=this._markers.get(markerDirective);return null==markerPromise?Promise.resolve():markerPromise.then(marker=>this._zone.run(()=>{marker.setMap(null),this._markers.delete(markerDirective)}))}updateMarkerPosition(marker){return this._markers.get(marker).then(m=>m.setPosition({lat:marker.latitude,lng:marker.longitude}))}updateTitle(marker){return this._markers.get(marker).then(m=>m.setTitle(marker.title))}updateLabel(marker){return this._markers.get(marker).then(m=>{m.setLabel(marker.label)})}updateDraggable(marker){return this._markers.get(marker).then(m=>m.setDraggable(marker.draggable))}updateIcon(marker){return this._markers.get(marker).then(m=>m.setIcon(marker.iconUrl))}updateOpacity(marker){return this._markers.get(marker).then(m=>m.setOpacity(marker.opacity))}updateVisible(marker){return this._markers.get(marker).then(m=>m.setVisible(marker.visible))}updateZIndex(marker){return this._markers.get(marker).then(m=>m.setZIndex(marker.zIndex))}updateClickable(marker){return this._markers.get(marker).then(m=>m.setClickable(marker.clickable))}updateAnimation(marker){return __awaiter(this,void 0,void 0,function*(){(yield this._markers.get(marker)).setAnimation(yield this.convertAnimation(marker.animation))})}addMarker(marker){const markerPromise=new Promise(resolve=>__awaiter(this,void 0,void 0,function*(){return this._mapsWrapper.createMarker({position:{lat:marker.latitude,lng:marker.longitude},label:marker.label,draggable:marker.draggable,icon:marker.iconUrl,opacity:marker.opacity,visible:marker.visible,zIndex:marker.zIndex,title:marker.title,clickable:marker.clickable,animation:yield this.convertAnimation(marker.animation)}).then(resolve)}));this._markers.set(marker,markerPromise)}getNativeMarker(marker){return this._markers.get(marker)}createEventObservable(eventName,marker){return new Observable.a(observer=>{this._markers.get(marker).then(m=>m.addListener(eventName,e=>this._zone.run(()=>observer.next(e))))})}}return MarkerManager.ɵfac=function(t){return new(t||MarkerManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper),core[\"ɵɵinject\"](core.NgZone))},MarkerManager.ɵprov=core[\"ɵɵdefineInjectable\"]({token:MarkerManager,factory:MarkerManager.ɵfac}),MarkerManager})(),agm_core_InfoWindowManager=(()=>{class InfoWindowManager{constructor(_mapsWrapper,_zone,_markerManager){this._mapsWrapper=_mapsWrapper,this._zone=_zone,this._markerManager=_markerManager,this._infoWindows=new Map}deleteInfoWindow(infoWindow){const iWindow=this._infoWindows.get(infoWindow);return null==iWindow?Promise.resolve():iWindow.then(i=>this._zone.run(()=>{i.close(),this._infoWindows.delete(infoWindow)}))}setPosition(infoWindow){return this._infoWindows.get(infoWindow).then(i=>i.setPosition({lat:infoWindow.latitude,lng:infoWindow.longitude}))}setZIndex(infoWindow){return this._infoWindows.get(infoWindow).then(i=>i.setZIndex(infoWindow.zIndex))}open(infoWindow){return this._infoWindows.get(infoWindow).then(w=>null!=infoWindow.hostMarker?this._markerManager.getNativeMarker(infoWindow.hostMarker).then(marker=>this._mapsWrapper.getNativeMap().then(map=>w.open(map,marker))):this._mapsWrapper.getNativeMap().then(map=>w.open(map)))}close(infoWindow){return this._infoWindows.get(infoWindow).then(w=>w.close())}setOptions(infoWindow,options){return this._infoWindows.get(infoWindow).then(i=>i.setOptions(options))}addInfoWindow(infoWindow){const options={content:infoWindow.content,maxWidth:infoWindow.maxWidth,zIndex:infoWindow.zIndex,disableAutoPan:infoWindow.disableAutoPan};\"number\"==typeof infoWindow.latitude&&\"number\"==typeof infoWindow.longitude&&(options.position={lat:infoWindow.latitude,lng:infoWindow.longitude});const infoWindowPromise=this._mapsWrapper.createInfoWindow(options);this._infoWindows.set(infoWindow,infoWindowPromise)}createEventObservable(eventName,infoWindow){return new Observable.a(observer=>{this._infoWindows.get(infoWindow).then(i=>{i.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}}return InfoWindowManager.ɵfac=function(t){return new(t||InfoWindowManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper),core[\"ɵɵinject\"](core.NgZone),core[\"ɵɵinject\"](agm_core_MarkerManager))},InfoWindowManager.ɵprov=core[\"ɵɵdefineInjectable\"]({token:InfoWindowManager,factory:InfoWindowManager.ɵfac}),InfoWindowManager})(),agm_core_KmlLayerManager=(()=>{class KmlLayerManager{constructor(_wrapper,_zone){this._wrapper=_wrapper,this._zone=_zone,this._layers=new Map}addKmlLayer(layer){const newLayer=this._wrapper.getNativeMap().then(m=>new google.maps.KmlLayer({clickable:layer.clickable,map:m,preserveViewport:layer.preserveViewport,screenOverlays:layer.screenOverlays,suppressInfoWindows:layer.suppressInfoWindows,url:layer.url,zIndex:layer.zIndex}));this._layers.set(layer,newLayer)}setOptions(layer,options){this._layers.get(layer).then(l=>l.setOptions(options))}deleteKmlLayer(layer){this._layers.get(layer).then(l=>{l.setMap(null),this._layers.delete(layer)})}createEventObservable(eventName,layer){return new Observable.a(observer=>{this._layers.get(layer).then(m=>{m.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}}return KmlLayerManager.ɵfac=function(t){return new(t||KmlLayerManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper),core[\"ɵɵinject\"](core.NgZone))},KmlLayerManager.ɵprov=core[\"ɵɵdefineInjectable\"]({token:KmlLayerManager,factory:KmlLayerManager.ɵfac}),KmlLayerManager})(),agm_core_LayerManager=(()=>{class LayerManager{constructor(_wrapper){this._wrapper=_wrapper,this._layers=new Map}addTransitLayer(layer){const newLayer=this._wrapper.createTransitLayer();this._layers.set(layer,newLayer)}addBicyclingLayer(layer){const newLayer=this._wrapper.createBicyclingLayer();this._layers.set(layer,newLayer)}deleteLayer(layer){return this._layers.get(layer).then(currentLayer=>{currentLayer.setMap(null),this._layers.delete(layer)})}}return LayerManager.ɵfac=function(t){return new(t||LayerManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper))},LayerManager.ɵprov=core[\"ɵɵdefineInjectable\"]({token:LayerManager,factory:LayerManager.ɵfac}),LayerManager})();function createMVCEventObservable(array){const eventNames=[\"insert_at\",\"remove_at\",\"set_at\"];return fromEventPattern(handler=>eventNames.map(eventName=>array.addListener(eventName,(index,previous)=>handler.apply(array,[{newArr:array.getArray(),eventName:eventName,index:index,previous:previous}]))),(_handler,evListeners)=>evListeners.forEach(evListener=>evListener.remove()))}let agm_core_PolygonManager=(()=>{class PolygonManager{constructor(_mapsWrapper,_zone){this._mapsWrapper=_mapsWrapper,this._zone=_zone,this._polygons=new Map}addPolygon(path){const polygonPromise=this._mapsWrapper.createPolygon({clickable:path.clickable,draggable:path.draggable,editable:path.editable,fillColor:path.fillColor,fillOpacity:path.fillOpacity,geodesic:path.geodesic,paths:path.paths,strokeColor:path.strokeColor,strokeOpacity:path.strokeOpacity,strokeWeight:path.strokeWeight,visible:path.visible,zIndex:path.zIndex});this._polygons.set(path,polygonPromise)}updatePolygon(polygon){const m=this._polygons.get(polygon);return null==m?Promise.resolve():m.then(l=>this._zone.run(()=>{l.setPaths(polygon.paths)}))}setPolygonOptions(path,options){return this._polygons.get(path).then(l=>{l.setOptions(options)})}deletePolygon(paths){const m=this._polygons.get(paths);return null==m?Promise.resolve():m.then(l=>this._zone.run(()=>{l.setMap(null),this._polygons.delete(paths)}))}getPath(polygonDirective){return this._polygons.get(polygonDirective).then(polygon=>polygon.getPath().getArray())}getPaths(polygonDirective){return this._polygons.get(polygonDirective).then(polygon=>polygon.getPaths().getArray().map(p=>p.getArray()))}createEventObservable(eventName,path){return new Observable.a(observer=>{this._polygons.get(path).then(l=>{l.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}createPathEventObservable(agmPolygon){return __awaiter(this,void 0,void 0,function*(){const paths=(yield this._polygons.get(agmPolygon)).getPaths();return createMVCEventObservable(paths).pipe(Object(startWith.a)({newArr:paths.getArray()}),Object(switchMap.a)(parentMVEvent=>Object(merge.a)(...parentMVEvent.newArr.map((chMVC,index)=>createMVCEventObservable(chMVC).pipe(Object(map.a)(chMVCEvent=>({parentMVEvent:parentMVEvent,chMVCEvent:chMVCEvent,pathIndex:index}))))).pipe(Object(startWith.a)({parentMVEvent:parentMVEvent,chMVCEvent:null,pathIndex:null}))),source=>source.lift(new SkipOperator(1)),Object(map.a)(({parentMVEvent:parentMVEvent,chMVCEvent:chMVCEvent,pathIndex:pathIndex})=>{let retVal;return chMVCEvent?(retVal={newArr:parentMVEvent.newArr.map(subArr=>subArr.getArray().map(latLng=>latLng.toJSON())),pathIndex:pathIndex,eventName:chMVCEvent.eventName,index:chMVCEvent.index},chMVCEvent.previous&&(retVal.previous=chMVCEvent.previous)):(retVal={newArr:parentMVEvent.newArr.map(subArr=>subArr.getArray().map(latLng=>latLng.toJSON())),eventName:parentMVEvent.eventName,index:parentMVEvent.index},parentMVEvent.previous&&(retVal.previous=parentMVEvent.previous.getArray())),retVal}))})}}return PolygonManager.ɵfac=function(t){return new(t||PolygonManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper),core[\"ɵɵinject\"](core.NgZone))},PolygonManager.ɵprov=core[\"ɵɵdefineInjectable\"]({token:PolygonManager,factory:PolygonManager.ɵfac}),PolygonManager})(),agm_core_PolylineManager=(()=>{class PolylineManager{constructor(_mapsWrapper,_zone){this._mapsWrapper=_mapsWrapper,this._zone=_zone,this._polylines=new Map}static _convertPoints(line){return line._getPoints().map(point=>({lat:point.latitude,lng:point.longitude}))}static _convertPath(path){const symbolPath=google.maps.SymbolPath[path];return\"number\"==typeof symbolPath?symbolPath:path}static _convertIcons(line){const icons=line._getIcons().map(agmIcon=>({fixedRotation:agmIcon.fixedRotation,offset:agmIcon.offset,repeat:agmIcon.repeat,icon:{anchor:new google.maps.Point(agmIcon.anchorX,agmIcon.anchorY),fillColor:agmIcon.fillColor,fillOpacity:agmIcon.fillOpacity,path:PolylineManager._convertPath(agmIcon.path),rotation:agmIcon.rotation,scale:agmIcon.scale,strokeColor:agmIcon.strokeColor,strokeOpacity:agmIcon.strokeOpacity,strokeWeight:agmIcon.strokeWeight}}));return icons.forEach(icon=>{Object.entries(icon).forEach(([key,val])=>{void 0===val&&delete icon[key]}),void 0!==icon.icon.anchor.x&&void 0!==icon.icon.anchor.y||delete icon.icon.anchor}),icons}addPolyline(line){const polylinePromise=this._mapsWrapper.getNativeMap().then(()=>[PolylineManager._convertPoints(line),PolylineManager._convertIcons(line)]).then(([path,icons])=>this._mapsWrapper.createPolyline({clickable:line.clickable,draggable:line.draggable,editable:line.editable,geodesic:line.geodesic,strokeColor:line.strokeColor,strokeOpacity:line.strokeOpacity,strokeWeight:line.strokeWeight,visible:line.visible,zIndex:line.zIndex,path:path,icons:icons}));this._polylines.set(line,polylinePromise)}updatePolylinePoints(line){const path=PolylineManager._convertPoints(line),m=this._polylines.get(line);return null==m?Promise.resolve():m.then(l=>this._zone.run(()=>l.setPath(path)))}updateIconSequences(line){return __awaiter(this,void 0,void 0,function*(){yield this._mapsWrapper.getNativeMap();const icons=PolylineManager._convertIcons(line),m=this._polylines.get(line);if(null!=m)return m.then(l=>this._zone.run(()=>l.setOptions({icons:icons})))})}setPolylineOptions(line,options){return this._polylines.get(line).then(l=>{l.setOptions(options)})}deletePolyline(line){const m=this._polylines.get(line);return null==m?Promise.resolve():m.then(l=>this._zone.run(()=>{l.setMap(null),this._polylines.delete(line)}))}getMVCPath(agmPolyline){return __awaiter(this,void 0,void 0,function*(){return(yield this._polylines.get(agmPolyline)).getPath()})}getPath(agmPolyline){return __awaiter(this,void 0,void 0,function*(){return(yield this.getMVCPath(agmPolyline)).getArray()})}createEventObservable(eventName,line){return new Observable.a(observer=>{this._polylines.get(line).then(l=>{l.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}createPathEventObservable(line){return __awaiter(this,void 0,void 0,function*(){return createMVCEventObservable(yield this.getMVCPath(line))})}}return PolylineManager.ɵfac=function(t){return new(t||PolylineManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper),core[\"ɵɵinject\"](core.NgZone))},PolylineManager.ɵprov=core[\"ɵɵdefineInjectable\"]({token:PolylineManager,factory:PolylineManager.ɵfac}),PolylineManager})(),agm_core_RectangleManager=(()=>{class RectangleManager{constructor(_apiWrapper,_zone){this._apiWrapper=_apiWrapper,this._zone=_zone,this._rectangles=new Map}addRectangle(rectangle){this._apiWrapper.getNativeMap().then(()=>this._rectangles.set(rectangle,this._apiWrapper.createRectangle({bounds:{north:rectangle.north,east:rectangle.east,south:rectangle.south,west:rectangle.west},clickable:rectangle.clickable,draggable:rectangle.draggable,editable:rectangle.editable,fillColor:rectangle.fillColor,fillOpacity:rectangle.fillOpacity,strokeColor:rectangle.strokeColor,strokeOpacity:rectangle.strokeOpacity,strokePosition:google.maps.StrokePosition[rectangle.strokePosition],strokeWeight:rectangle.strokeWeight,visible:rectangle.visible,zIndex:rectangle.zIndex})))}removeRectangle(rectangle){return this._rectangles.get(rectangle).then(r=>{r.setMap(null),this._rectangles.delete(rectangle)})}setOptions(rectangle,options){return this._rectangles.get(rectangle).then(r=>{options.strokePosition=google.maps.StrokePosition[options.strokePosition],r.setOptions(options)})}getBounds(rectangle){return this._rectangles.get(rectangle).then(r=>r.getBounds())}setBounds(rectangle){return this._rectangles.get(rectangle).then(r=>r.setBounds({north:rectangle.north,east:rectangle.east,south:rectangle.south,west:rectangle.west}))}setEditable(rectangle){return this._rectangles.get(rectangle).then(r=>r.setEditable(rectangle.editable))}setDraggable(rectangle){return this._rectangles.get(rectangle).then(r=>r.setDraggable(rectangle.draggable))}setVisible(rectangle){return this._rectangles.get(rectangle).then(r=>r.setVisible(rectangle.visible))}createEventObservable(eventName,rectangle){return new Observable.a(subsrciber=>{let listener=null;return this._rectangles.get(rectangle).then(r=>{listener=r.addListener(eventName,e=>this._zone.run(()=>subsrciber.next(e)))}),()=>{null!==listener&&listener.remove()}})}}return RectangleManager.ɵfac=function(t){return new(t||RectangleManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper),core[\"ɵɵinject\"](core.NgZone))},RectangleManager.ɵprov=core[\"ɵɵdefineInjectable\"]({token:RectangleManager,factory:RectangleManager.ɵfac}),RectangleManager})(),infoWindowId=0,agm_core_AgmInfoWindow=(()=>{class AgmInfoWindow{constructor(_infoWindowManager,_el){this._infoWindowManager=_infoWindowManager,this._el=_el,this.isOpen=!1,this.infoWindowClose=new core.EventEmitter,this._infoWindowAddedToManager=!1,this._id=(infoWindowId++).toString()}ngOnInit(){this.content=this._el.nativeElement.querySelector(\".agm-info-window-content\"),this._infoWindowManager.addInfoWindow(this),this._infoWindowAddedToManager=!0,this._updateOpenState(),this._registerEventListeners()}ngOnChanges(changes){this._infoWindowAddedToManager&&((changes.latitude||changes.longitude)&&\"number\"==typeof this.latitude&&\"number\"==typeof this.longitude&&this._infoWindowManager.setPosition(this),changes.zIndex&&this._infoWindowManager.setZIndex(this),changes.isOpen&&this._updateOpenState(),this._setInfoWindowOptions(changes))}_registerEventListeners(){this._infoWindowManager.createEventObservable(\"closeclick\",this).subscribe(()=>{this.isOpen=!1,this.infoWindowClose.emit()})}_updateOpenState(){this.isOpen?this.open():this.close()}_setInfoWindowOptions(changes){const options={};Object.keys(changes).filter(k=>-1!==AgmInfoWindow._infoWindowOptionsInputs.indexOf(k)).forEach(k=>{options[k]=changes[k].currentValue}),this._infoWindowManager.setOptions(this,options)}open(){return this._infoWindowManager.open(this)}close(){return this._infoWindowManager.close(this).then(()=>{this.infoWindowClose.emit()})}id(){return this._id}toString(){return\"AgmInfoWindow-\"+this._id.toString()}ngOnDestroy(){this._infoWindowManager.deleteInfoWindow(this)}}return AgmInfoWindow.ɵfac=function(t){return new(t||AgmInfoWindow)(core[\"ɵɵdirectiveInject\"](agm_core_InfoWindowManager),core[\"ɵɵdirectiveInject\"](core.ElementRef))},AgmInfoWindow.ɵcmp=core[\"ɵɵdefineComponent\"]({type:AgmInfoWindow,selectors:[[\"agm-info-window\"]],inputs:{isOpen:\"isOpen\",latitude:\"latitude\",longitude:\"longitude\",disableAutoPan:\"disableAutoPan\",zIndex:\"zIndex\",maxWidth:\"maxWidth\"},outputs:{infoWindowClose:\"infoWindowClose\"},features:[core[\"ɵɵNgOnChangesFeature\"]],ngContentSelectors:_c0,decls:2,vars:0,consts:[[1,\"agm-info-window-content\"]],template:function(rf,ctx){1&rf&&(core[\"ɵɵprojectionDef\"](),core[\"ɵɵelementStart\"](0,\"div\",0),core[\"ɵɵprojection\"](1),core[\"ɵɵelementEnd\"]())},encapsulation:2}),AgmInfoWindow._infoWindowOptionsInputs=[\"disableAutoPan\",\"maxWidth\"],AgmInfoWindow})(),agm_core_AgmMapControl=(()=>{class AgmMapControl{}return AgmMapControl.ɵfac=function(t){return new(t||AgmMapControl)},AgmMapControl.ɵdir=core[\"ɵɵdefineDirective\"]({type:AgmMapControl,inputs:{position:\"position\"}}),AgmMapControl})(),agm_core_AgmMap=(()=>{class AgmMap{constructor(_elem,_mapsWrapper,_platformId,_fitBoundsService,_zone){this._elem=_elem,this._mapsWrapper=_mapsWrapper,this._platformId=_platformId,this._fitBoundsService=_fitBoundsService,this._zone=_zone,this.longitude=0,this.latitude=0,this.zoom=8,this.draggable=!0,this.disableDoubleClickZoom=!1,this.disableDefaultUI=!1,this.scrollwheel=!0,this.keyboardShortcuts=!0,this.styles=[],this.usePanning=!1,this.fitBounds=!1,this.mapTypeId=\"ROADMAP\",this.clickableIcons=!0,this.showDefaultInfoWindow=!0,this.gestureHandling=\"auto\",this.tilt=0,this._observableSubscriptions=[],this.mapClick=new core.EventEmitter,this.mapRightClick=new core.EventEmitter,this.mapDblClick=new core.EventEmitter,this.centerChange=new core.EventEmitter,this.boundsChange=new core.EventEmitter,this.mapTypeIdChange=new core.EventEmitter,this.idle=new core.EventEmitter,this.zoomChange=new core.EventEmitter,this.mapReady=new core.EventEmitter,this.tilesLoaded=new core.EventEmitter}ngAfterContentInit(){if(Object(common.r)(this._platformId))return;const container=this._elem.nativeElement.querySelector(\".agm-map-container-inner\");this._initMapInstance(container)}_initMapInstance(el){this._mapsWrapper.createMap(el,{center:{lat:this.latitude||0,lng:this.longitude||0},zoom:this.zoom,minZoom:this.minZoom,maxZoom:this.maxZoom,controlSize:this.controlSize,disableDefaultUI:this.disableDefaultUI,disableDoubleClickZoom:this.disableDoubleClickZoom,scrollwheel:this.scrollwheel,backgroundColor:this.backgroundColor,draggable:this.draggable,draggableCursor:this.draggableCursor,draggingCursor:this.draggingCursor,keyboardShortcuts:this.keyboardShortcuts,styles:this.styles,mapTypeId:this.mapTypeId.toLocaleLowerCase(),clickableIcons:this.clickableIcons,gestureHandling:this.gestureHandling,tilt:this.tilt,restriction:this.restriction}).then(()=>this._mapsWrapper.getNativeMap()).then(map=>this.mapReady.emit(map)),this._handleMapCenterChange(),this._handleMapZoomChange(),this._handleMapMouseEvents(),this._handleBoundsChange(),this._handleMapTypeIdChange(),this._handleTilesLoadedEvent(),this._handleIdleEvent(),this._handleControlChange()}ngOnDestroy(){this._observableSubscriptions.forEach(s=>s.unsubscribe()),this._mapsWrapper.clearInstanceListeners(),this._fitBoundsSubscription&&this._fitBoundsSubscription.unsubscribe()}ngOnChanges(changes){this._updateMapOptionsChanges(changes),this._updatePosition(changes)}_updateMapOptionsChanges(changes){const options={};Object.keys(changes).filter(k=>-1!==AgmMap._mapOptionsAttributes.indexOf(k)).forEach(k=>{options[k]=changes[k].currentValue}),this._mapsWrapper.setMapOptions(options)}triggerResize(recenter=!0){return new Promise(resolve=>{setTimeout(()=>this._mapsWrapper.triggerMapEvent(\"resize\").then(()=>{recenter&&(null!=this.fitBounds?this._fitBounds():this._setCenter()),resolve()}))})}_updatePosition(changes){(null!=changes.latitude||null!=changes.longitude||changes.fitBounds)&&(\"fitBounds\"in changes?this._fitBounds():\"number\"==typeof this.latitude&&\"number\"==typeof this.longitude&&this._setCenter())}_setCenter(){const newCenter={lat:this.latitude,lng:this.longitude};this.usePanning?this._mapsWrapper.panTo(newCenter):this._mapsWrapper.setCenter(newCenter)}_fitBounds(){switch(this.fitBounds){case!0:this._subscribeToFitBoundsUpdates();break;case!1:this._fitBoundsSubscription&&this._fitBoundsSubscription.unsubscribe();break;default:this._fitBoundsSubscription&&this._fitBoundsSubscription.unsubscribe(),this._updateBounds(this.fitBounds,this.fitBoundsPadding)}}_subscribeToFitBoundsUpdates(){this._zone.runOutsideAngular(()=>{this._fitBoundsSubscription=this._fitBoundsService.getBounds$().subscribe(b=>{this._zone.run(()=>this._updateBounds(b,this.fitBoundsPadding))})})}_updateBounds(bounds,padding){if(bounds){if(this._isLatLngBoundsLiteral(bounds)&&\"undefined\"!=typeof google&&google&&google.maps&&google.maps.LatLngBounds){const newBounds=new google.maps.LatLngBounds;newBounds.union(bounds),bounds=newBounds}this.usePanning?this._mapsWrapper.panToBounds(bounds,padding):this._mapsWrapper.fitBounds(bounds,padding)}}_isLatLngBoundsLiteral(bounds){return null!=bounds&&void 0===bounds.extend}_handleMapCenterChange(){const s=this._mapsWrapper.subscribeToMapEvent(\"center_changed\").subscribe(()=>{this._mapsWrapper.getCenter().then(center=>{this.latitude=center.lat(),this.longitude=center.lng(),this.centerChange.emit({lat:this.latitude,lng:this.longitude})})});this._observableSubscriptions.push(s)}_handleBoundsChange(){const s=this._mapsWrapper.subscribeToMapEvent(\"bounds_changed\").subscribe(()=>{this._mapsWrapper.getBounds().then(bounds=>{this.boundsChange.emit(bounds)})});this._observableSubscriptions.push(s)}_handleMapTypeIdChange(){const s=this._mapsWrapper.subscribeToMapEvent(\"maptypeid_changed\").subscribe(()=>{this._mapsWrapper.getMapTypeId().then(mapTypeId=>{this.mapTypeIdChange.emit(mapTypeId)})});this._observableSubscriptions.push(s)}_handleMapZoomChange(){const s=this._mapsWrapper.subscribeToMapEvent(\"zoom_changed\").subscribe(()=>{this._mapsWrapper.getZoom().then(z=>{this.zoom=z,this.zoomChange.emit(z)})});this._observableSubscriptions.push(s)}_handleIdleEvent(){const s=this._mapsWrapper.subscribeToMapEvent(\"idle\").subscribe(()=>{this.idle.emit(void 0)});this._observableSubscriptions.push(s)}_handleTilesLoadedEvent(){const s=this._mapsWrapper.subscribeToMapEvent(\"tilesloaded\").subscribe(()=>this.tilesLoaded.emit(void 0));this._observableSubscriptions.push(s)}_handleMapMouseEvents(){[{name:\"click\",emitter:this.mapClick},{name:\"rightclick\",emitter:this.mapRightClick},{name:\"dblclick\",emitter:this.mapDblClick}].forEach(e=>{const s=this._mapsWrapper.subscribeToMapEvent(e.name).subscribe(([event])=>{event.placeId&&!this.showDefaultInfoWindow&&event.stop(),e.emitter.emit(event)});this._observableSubscriptions.push(s)})}_handleControlChange(){this._setControls(),this.mapControls.changes.subscribe(()=>this._setControls())}_setControls(){const controlOptions={fullscreenControl:!this.disableDefaultUI,mapTypeControl:!1,panControl:!1,rotateControl:!1,scaleControl:!1,streetViewControl:!this.disableDefaultUI,zoomControl:!this.disableDefaultUI};this._mapsWrapper.getNativeMap().then(()=>{this.mapControls.forEach(control=>Object.assign(controlOptions,control.getOptions())),this._mapsWrapper.setMapOptions(controlOptions)})}}return AgmMap.ɵfac=function(t){return new(t||AgmMap)(core[\"ɵɵdirectiveInject\"](core.ElementRef),core[\"ɵɵdirectiveInject\"](agm_core_GoogleMapsAPIWrapper),core[\"ɵɵdirectiveInject\"](core.PLATFORM_ID),core[\"ɵɵdirectiveInject\"](agm_core_FitBoundsService),core[\"ɵɵdirectiveInject\"](core.NgZone))},AgmMap.ɵcmp=core[\"ɵɵdefineComponent\"]({type:AgmMap,selectors:[[\"agm-map\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&core[\"ɵɵcontentQuery\"](dirIndex,agm_core_AgmMapControl,0),2&rf){let _t;core[\"ɵɵqueryRefresh\"](_t=core[\"ɵɵloadQuery\"]())&&(ctx.mapControls=_t)}},inputs:{longitude:\"longitude\",latitude:\"latitude\",zoom:\"zoom\",draggable:[\"mapDraggable\",\"draggable\"],disableDoubleClickZoom:\"disableDoubleClickZoom\",disableDefaultUI:\"disableDefaultUI\",scrollwheel:\"scrollwheel\",keyboardShortcuts:\"keyboardShortcuts\",styles:\"styles\",usePanning:\"usePanning\",fitBounds:\"fitBounds\",mapTypeId:\"mapTypeId\",clickableIcons:\"clickableIcons\",showDefaultInfoWindow:\"showDefaultInfoWindow\",gestureHandling:\"gestureHandling\",tilt:\"tilt\",minZoom:\"minZoom\",maxZoom:\"maxZoom\",controlSize:\"controlSize\",backgroundColor:\"backgroundColor\",draggableCursor:\"draggableCursor\",draggingCursor:\"draggingCursor\",fitBoundsPadding:\"fitBoundsPadding\",restriction:\"restriction\"},outputs:{mapClick:\"mapClick\",mapRightClick:\"mapRightClick\",mapDblClick:\"mapDblClick\",centerChange:\"centerChange\",boundsChange:\"boundsChange\",mapTypeIdChange:\"mapTypeIdChange\",idle:\"idle\",zoomChange:\"zoomChange\",mapReady:\"mapReady\",tilesLoaded:\"tilesLoaded\"},features:[core[\"ɵɵProvidersFeature\"]([agm_core_CircleManager,agm_core_DataLayerManager,agm_core_DataLayerManager,agm_core_FitBoundsService,agm_core_GoogleMapsAPIWrapper,agm_core_InfoWindowManager,agm_core_KmlLayerManager,agm_core_LayerManager,agm_core_MarkerManager,agm_core_PolygonManager,agm_core_PolylineManager,agm_core_RectangleManager]),core[\"ɵɵNgOnChangesFeature\"]],ngContentSelectors:_c0,decls:3,vars:0,consts:[[1,\"agm-map-container-inner\",\"sebm-google-map-container-inner\"],[1,\"agm-map-content\"]],template:function(rf,ctx){1&rf&&(core[\"ɵɵprojectionDef\"](),core[\"ɵɵelement\"](0,\"div\",0),core[\"ɵɵelementStart\"](1,\"div\",1),core[\"ɵɵprojection\"](2),core[\"ɵɵelementEnd\"]())},styles:[\".agm-map-container-inner[_ngcontent-%COMP%] {\\n      width: inherit;\\n      height: inherit;\\n    }\\n    .agm-map-content[_ngcontent-%COMP%] {\\n      display:none;\\n    }\"]}),AgmMap._mapOptionsAttributes=[\"disableDoubleClickZoom\",\"scrollwheel\",\"draggable\",\"draggableCursor\",\"draggingCursor\",\"keyboardShortcuts\",\"styles\",\"zoom\",\"minZoom\",\"maxZoom\",\"mapTypeId\",\"clickableIcons\",\"gestureHandling\",\"tilt\",\"restriction\"],AgmMap})(),markerId=0,agm_core_AgmMarker=(()=>{class AgmMarker{constructor(_markerManager){this._markerManager=_markerManager,this.draggable=!1,this.visible=!0,this.openInfoWindow=!0,this.opacity=1,this.zIndex=1,this.clickable=!0,this.animationChange=new core.EventEmitter,this.markerClick=new core.EventEmitter,this.markerDblClick=new core.EventEmitter,this.markerRightClick=new core.EventEmitter,this.dragStart=new core.EventEmitter,this.drag=new core.EventEmitter,this.dragEnd=new core.EventEmitter,this.mouseOver=new core.EventEmitter,this.mouseOut=new core.EventEmitter,this.infoWindow=new core.QueryList,this._markerAddedToManger=!1,this._observableSubscriptions=[],this._fitBoundsDetails$=new ReplaySubject_ReplaySubject(1),this._id=(markerId++).toString()}ngAfterContentInit(){this.handleInfoWindowUpdate(),this.infoWindow.changes.subscribe(()=>this.handleInfoWindowUpdate())}handleInfoWindowUpdate(){if(this.infoWindow.length>1)throw new Error(\"Expected no more than one info window.\");this.infoWindow.forEach(marker=>{marker.hostMarker=this})}ngOnChanges(changes){if(\"string\"==typeof this.latitude&&(this.latitude=Number(this.latitude)),\"string\"==typeof this.longitude&&(this.longitude=Number(this.longitude)),\"number\"==typeof this.latitude&&\"number\"==typeof this.longitude){if(!this._markerAddedToManger)return this._markerManager.addMarker(this),this._updateFitBoundsDetails(),this._markerAddedToManger=!0,void this._addEventListeners();(changes.latitude||changes.longitude)&&(this._markerManager.updateMarkerPosition(this),this._updateFitBoundsDetails()),changes.title&&this._markerManager.updateTitle(this),changes.label&&this._markerManager.updateLabel(this),changes.draggable&&this._markerManager.updateDraggable(this),changes.iconUrl&&this._markerManager.updateIcon(this),changes.opacity&&this._markerManager.updateOpacity(this),changes.visible&&this._markerManager.updateVisible(this),changes.zIndex&&this._markerManager.updateZIndex(this),changes.clickable&&this._markerManager.updateClickable(this),changes.animation&&this._markerManager.updateAnimation(this)}}getFitBoundsDetails$(){return this._fitBoundsDetails$.asObservable()}_updateFitBoundsDetails(){this._fitBoundsDetails$.next({latLng:{lat:this.latitude,lng:this.longitude}})}_addEventListeners(){const cs=this._markerManager.createEventObservable(\"click\",this).subscribe(()=>{this.openInfoWindow&&this.infoWindow.forEach(infoWindow=>infoWindow.open()),this.markerClick.emit(this)});this._observableSubscriptions.push(cs);const dcs=this._markerManager.createEventObservable(\"dblclick\",this).subscribe(()=>{this.markerDblClick.emit(null)});this._observableSubscriptions.push(dcs);const rc=this._markerManager.createEventObservable(\"rightclick\",this).subscribe(()=>{this.markerRightClick.emit(null)});this._observableSubscriptions.push(rc);const ds=this._markerManager.createEventObservable(\"dragstart\",this).subscribe(e=>this.dragStart.emit(e));this._observableSubscriptions.push(ds);const d=this._markerManager.createEventObservable(\"drag\",this).subscribe(e=>this.drag.emit(e));this._observableSubscriptions.push(d);const de=this._markerManager.createEventObservable(\"dragend\",this).subscribe(e=>this.dragEnd.emit(e));this._observableSubscriptions.push(de);const mover=this._markerManager.createEventObservable(\"mouseover\",this).subscribe(e=>this.mouseOver.emit(e));this._observableSubscriptions.push(mover);const mout=this._markerManager.createEventObservable(\"mouseout\",this).subscribe(e=>this.mouseOut.emit(e));this._observableSubscriptions.push(mout);const anChng=this._markerManager.createEventObservable(\"animation_changed\",this).subscribe(()=>{this.animationChange.emit(this.animation)});this._observableSubscriptions.push(anChng)}id(){return this._id}toString(){return\"AgmMarker-\"+this._id.toString()}ngOnDestroy(){this._markerManager.deleteMarker(this),this._observableSubscriptions.forEach(s=>s.unsubscribe())}}return AgmMarker.ɵfac=function(t){return new(t||AgmMarker)(core[\"ɵɵdirectiveInject\"](agm_core_MarkerManager))},AgmMarker.ɵdir=core[\"ɵɵdefineDirective\"]({type:AgmMarker,selectors:[[\"agm-marker\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&core[\"ɵɵcontentQuery\"](dirIndex,agm_core_AgmInfoWindow,0),2&rf){let _t;core[\"ɵɵqueryRefresh\"](_t=core[\"ɵɵloadQuery\"]())&&(ctx.infoWindow=_t)}},inputs:{draggable:[\"markerDraggable\",\"draggable\"],visible:\"visible\",openInfoWindow:\"openInfoWindow\",opacity:\"opacity\",zIndex:\"zIndex\",clickable:[\"markerClickable\",\"clickable\"],latitude:\"latitude\",longitude:\"longitude\",title:\"title\",label:\"label\",iconUrl:\"iconUrl\",animation:\"animation\"},outputs:{animationChange:\"animationChange\",markerClick:\"markerClick\",markerDblClick:\"markerDblClick\",markerRightClick:\"markerRightClick\",dragStart:\"dragStart\",drag:\"drag\",dragEnd:\"dragEnd\",mouseOver:\"mouseOver\",mouseOut:\"mouseOut\"},features:[core[\"ɵɵProvidersFeature\"]([{provide:FitBoundsAccessor,useExisting:Object(core.forwardRef)(()=>AgmMarker)}]),core[\"ɵɵNgOnChangesFeature\"]]}),AgmMarker})(),agm_core_AgmCoreModule=(()=>{class AgmCoreModule{static forRoot(lazyMapsAPILoaderConfig){return{ngModule:AgmCoreModule,providers:[...BROWSER_GLOBALS_PROVIDERS,{provide:agm_core_MapsAPILoader,useClass:agm_core_LazyMapsAPILoader},{provide:LAZY_MAPS_API_CONFIG,useValue:lazyMapsAPILoaderConfig}]}}}return AgmCoreModule.ɵfac=function(t){return new(t||AgmCoreModule)},AgmCoreModule.ɵmod=core[\"ɵɵdefineNgModule\"]({type:AgmCoreModule}),AgmCoreModule.ɵinj=core[\"ɵɵdefineInjector\"]({}),AgmCoreModule})()}}]);","name":"1-es2015.51921b83267bbf0956e2.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[1],{\n\n/***/ \"cxbk\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return environment; });\n/* unused harmony export countryCode */\nconst environment = {\r\n    production: true,\r\n    google_map_key: \"AIzaSyCb9lhLYxUnRjSp1oIGl6aAsXLODc3o-f4\",\r\n};\r\nconst countryCode = [\r\n    { name: \"Afghanistan\", dial_code: \"+93\", code: \"AF\" },\r\n    { name: \"Albania\", dial_code: \"+355\", code: \"AL\" },\r\n    { name: \"Algeria\", dial_code: \"+213\", code: \"DZ\" },\r\n    { name: \"AmericanSamoa\", dial_code: \"+1 684\", code: \"AS\" },\r\n    { name: \"Andorra\", dial_code: \"+376\", code: \"AD\" },\r\n    { name: \"Angola\", dial_code: \"+244\", code: \"AO\" },\r\n    { name: \"Anguilla\", dial_code: \"+1 264\", code: \"AI\" },\r\n    { name: \"Antarctica\", dial_code: \"+672\", code: \"AQ\" },\r\n    { name: \"Antigua and Barbuda\", dial_code: \"+1268\", code: \"AG\" },\r\n    { name: \"Argentina\", dial_code: \"+54\", code: \"AR\" },\r\n    { name: \"Armenia\", dial_code: \"+374\", code: \"AM\" },\r\n    { name: \"Aruba\", dial_code: \"+297\", code: \"AW\" },\r\n    { name: \"Australia\", dial_code: \"+61\", code: \"AU\" },\r\n    { name: \"Austria\", dial_code: \"+43\", code: \"AT\" },\r\n    { name: \"Azerbaijan\", dial_code: \"+994\", code: \"AZ\" },\r\n    { name: \"Bahamas\", dial_code: \"+1 242\", code: \"BS\" },\r\n    { name: \"Bahrain\", dial_code: \"+973\", code: \"BH\" },\r\n    { name: \"Bangladesh\", dial_code: \"+880\", code: \"BD\" },\r\n    { name: \"Barbados\", dial_code: \"+1 246\", code: \"BB\" },\r\n    { name: \"Belarus\", dial_code: \"+375\", code: \"BY\" },\r\n    { name: \"Belgium\", dial_code: \"+32\", code: \"BE\" },\r\n    { name: \"Belize\", dial_code: \"+501\", code: \"BZ\" },\r\n    { name: \"Benin\", dial_code: \"+229\", code: \"BJ\" },\r\n    { name: \"Bermuda\", dial_code: \"+1 441\", code: \"BM\" },\r\n    { name: \"Bhutan\", dial_code: \"+975\", code: \"BT\" },\r\n    { name: \"Bolivia, Plurinational State of\", dial_code: \"+591\", code: \"BO\" },\r\n    { name: \"Bosnia and Herzegovina\", dial_code: \"+387\", code: \"BA\" },\r\n    { name: \"Botswana\", dial_code: \"+267\", code: \"BW\" },\r\n    { name: \"Brazil\", dial_code: \"+55\", code: \"BR\" },\r\n    { name: \"British Indian Ocean Territory\", dial_code: \"+246\", code: \"IO\" },\r\n    { name: \"Brunei Darussalam\", dial_code: \"+673\", code: \"BN\" },\r\n    { name: \"Bulgaria\", dial_code: \"+359\", code: \"BG\" },\r\n    { name: \"Burkina Faso\", dial_code: \"+226\", code: \"BF\" },\r\n    { name: \"Burundi\", dial_code: \"+257\", code: \"BI\" },\r\n    { name: \"Cambodia\", dial_code: \"+855\", code: \"KH\" },\r\n    { name: \"Cameroon\", dial_code: \"+237\", code: \"CM\" },\r\n    { name: \"Canada\", dial_code: \"+1\", code: \"CA\" },\r\n    { name: \"Cape Verde\", dial_code: \"+238\", code: \"CV\" },\r\n    { name: \"Cayman Islands\", dial_code: \"+ 345\", code: \"KY\" },\r\n    { name: \"Central African Republic\", dial_code: \"+236\", code: \"CF\" },\r\n    { name: \"Chad\", dial_code: \"+235\", code: \"TD\" },\r\n    { name: \"Chile\", dial_code: \"+56\", code: \"CL\" },\r\n    { name: \"China\", dial_code: \"+86\", code: \"CN\" },\r\n    { name: \"Christmas Island\", dial_code: \"+61\", code: \"CX\" },\r\n    { name: \"Cocos (Keeling) Islands\", dial_code: \"+61\", code: \"CC\" },\r\n    { name: \"Colombia\", dial_code: \"+57\", code: \"CO\" },\r\n    { name: \"Comoros\", dial_code: \"+269\", code: \"KM\" },\r\n    { name: \"Congo\", dial_code: \"+242\", code: \"CG\" },\r\n    {\r\n        name: \"Congo, The Democratic Republic of the\",\r\n        dial_code: \"+243\",\r\n        code: \"CD\",\r\n    },\r\n    { name: \"Cook Islands\", dial_code: \"+682\", code: \"CK\" },\r\n    { name: \"Costa Rica\", dial_code: \"+506\", code: \"CR\" },\r\n    { name: \"Cote d'Ivoire\", dial_code: \"+225\", code: \"CI\" },\r\n    { name: \"Croatia\", dial_code: \"+385\", code: \"HR\" },\r\n    { name: \"Cuba\", dial_code: \"+53\", code: \"CU\" },\r\n    { name: \"Cyprus\", dial_code: \"+357\", code: \"CY\" },\r\n    { name: \"Czech Republic\", dial_code: \"+420\", code: \"CZ\" },\r\n    { name: \"Denmark\", dial_code: \"+45\", code: \"DK\" },\r\n    { name: \"Djibouti\", dial_code: \"+253\", code: \"DJ\" },\r\n    { name: \"Dominica\", dial_code: \"+1 767\", code: \"DM\" },\r\n    { name: \"Dominican Republic\", dial_code: \"+1 849\", code: \"DO\" },\r\n    { name: \"Ecuador\", dial_code: \"+593\", code: \"EC\" },\r\n    { name: \"Egypt\", dial_code: \"+20\", code: \"EG\" },\r\n    { name: \"El Salvador\", dial_code: \"+503\", code: \"SV\" },\r\n    { name: \"Equatorial Guinea\", dial_code: \"+240\", code: \"GQ\" },\r\n    { name: \"Eritrea\", dial_code: \"+291\", code: \"ER\" },\r\n    { name: \"Estonia\", dial_code: \"+372\", code: \"EE\" },\r\n    { name: \"Ethiopia\", dial_code: \"+251\", code: \"ET\" },\r\n    { name: \"Falkland Islands (Malvinas)\", dial_code: \"+500\", code: \"FK\" },\r\n    { name: \"Faroe Islands\", dial_code: \"+298\", code: \"FO\" },\r\n    { name: \"Fiji\", dial_code: \"+679\", code: \"FJ\" },\r\n    { name: \"Finland\", dial_code: \"+358\", code: \"FI\" },\r\n    { name: \"France\", dial_code: \"+33\", code: \"FR\" },\r\n    { name: \"French Guiana\", dial_code: \"+594\", code: \"GF\" },\r\n    { name: \"French Polynesia\", dial_code: \"+689\", code: \"PF\" },\r\n    { name: \"Gabon\", dial_code: \"+241\", code: \"GA\" },\r\n    { name: \"Gambia\", dial_code: \"+220\", code: \"GM\" },\r\n    { name: \"Georgia\", dial_code: \"+995\", code: \"GE\" },\r\n    { name: \"Germany\", dial_code: \"+49\", code: \"DE\" },\r\n    { name: \"Ghana\", dial_code: \"+233\", code: \"GH\" },\r\n    { name: \"Gibraltar\", dial_code: \"+350\", code: \"GI\" },\r\n    { name: \"Greece\", dial_code: \"+30\", code: \"GR\" },\r\n    { name: \"Greenland\", dial_code: \"+299\", code: \"GL\" },\r\n    { name: \"Grenada\", dial_code: \"+1 473\", code: \"GD\" },\r\n    { name: \"Guadeloupe\", dial_code: \"+590\", code: \"GP\" },\r\n    { name: \"Guam\", dial_code: \"+1 671\", code: \"GU\" },\r\n    { name: \"Guatemala\", dial_code: \"+502\", code: \"GT\" },\r\n    { name: \"Guernsey\", dial_code: \"+44\", code: \"GG\" },\r\n    { name: \"Guinea\", dial_code: \"+224\", code: \"GN\" },\r\n    { name: \"Guinea-Bissau\", dial_code: \"+245\", code: \"GW\" },\r\n    { name: \"Guyana\", dial_code: \"+595\", code: \"GY\" },\r\n    { name: \"Haiti\", dial_code: \"+509\", code: \"HT\" },\r\n    { name: \"Holy See (Vatican City State)\", dial_code: \"+379\", code: \"VA\" },\r\n    { name: \"Honduras\", dial_code: \"+504\", code: \"HN\" },\r\n    { name: \"Hong Kong\", dial_code: \"+852\", code: \"HK\" },\r\n    { name: \"Hungary\", dial_code: \"+36\", code: \"HU\" },\r\n    { name: \"Iceland\", dial_code: \"+354\", code: \"IS\" },\r\n    { name: \"India\", dial_code: \"+91\", code: \"IN\" },\r\n    { name: \"Indonesia\", dial_code: \"+62\", code: \"ID\" },\r\n    { name: \"Iran, Islamic Republic of\", dial_code: \"+98\", code: \"IR\" },\r\n    { name: \"Iraq\", dial_code: \"+964\", code: \"IQ\" },\r\n    { name: \"Ireland\", dial_code: \"+353\", code: \"IE\" },\r\n    { name: \"Isle of Man\", dial_code: \"+44\", code: \"IM\" },\r\n    { name: \"Israel\", dial_code: \"+972\", code: \"IL\" },\r\n    { name: \"Italy\", dial_code: \"+39\", code: \"IT\" },\r\n    { name: \"Jamaica\", dial_code: \"+1 876\", code: \"JM\" },\r\n    { name: \"Japan\", dial_code: \"+81\", code: \"JP\" },\r\n    { name: \"Jersey\", dial_code: \"+44\", code: \"JE\" },\r\n    { name: \"Jordan\", dial_code: \"+962\", code: \"JO\" },\r\n    { name: \"Kazakhstan\", dial_code: \"+7 7\", code: \"KZ\" },\r\n    { name: \"Kenya\", dial_code: \"+254\", code: \"KE\" },\r\n    { name: \"Kiribati\", dial_code: \"+686\", code: \"KI\" },\r\n    {\r\n        name: \"Korea, Democratic People's Republic of\",\r\n        dial_code: \"+850\",\r\n        code: \"KP\",\r\n    },\r\n    { name: \"Korea, Republic of\", dial_code: \"+82\", code: \"KR\" },\r\n    { name: \"Kuwait\", dial_code: \"+965\", code: \"KW\" },\r\n    { name: \"Kyrgyzstan\", dial_code: \"+996\", code: \"KG\" },\r\n    { name: \"Lao People's Democratic Republic\", dial_code: \"+856\", code: \"LA\" },\r\n    { name: \"Latvia\", dial_code: \"+371\", code: \"LV\" },\r\n    { name: \"Lebanon\", dial_code: \"+961\", code: \"LB\" },\r\n    { name: \"Lesotho\", dial_code: \"+266\", code: \"LS\" },\r\n    { name: \"Liberia\", dial_code: \"+231\", code: \"LR\" },\r\n    { name: \"Libyan Arab Jamahiriya\", dial_code: \"+218\", code: \"LY\" },\r\n    { name: \"Liechtenstein\", dial_code: \"+423\", code: \"LI\" },\r\n    { name: \"Lithuania\", dial_code: \"+370\", code: \"LT\" },\r\n    { name: \"Luxembourg\", dial_code: \"+352\", code: \"LU\" },\r\n    { name: \"Macao\", dial_code: \"+853\", code: \"MO\" },\r\n    {\r\n        name: \"Macedonia, The Former Yugoslav Republic of\",\r\n        dial_code: \"+389\",\r\n        code: \"MK\",\r\n    },\r\n    { name: \"Madagascar\", dial_code: \"+261\", code: \"MG\" },\r\n    { name: \"Malawi\", dial_code: \"+265\", code: \"MW\" },\r\n    { name: \"Malaysia\", dial_code: \"+60\", code: \"MY\" },\r\n    { name: \"Maldives\", dial_code: \"+960\", code: \"MV\" },\r\n    { name: \"Mali\", dial_code: \"+223\", code: \"ML\" },\r\n    { name: \"Malta\", dial_code: \"+356\", code: \"MT\" },\r\n    { name: \"Marshall Islands\", dial_code: \"+692\", code: \"MH\" },\r\n    { name: \"Martinique\", dial_code: \"+596\", code: \"MQ\" },\r\n    { name: \"Mauritania\", dial_code: \"+222\", code: \"MR\" },\r\n    { name: \"Mauritius\", dial_code: \"+230\", code: \"MU\" },\r\n    { name: \"Mayotte\", dial_code: \"+262\", code: \"YT\" },\r\n    { name: \"Mexico\", dial_code: \"+52\", code: \"MX\" },\r\n    { name: \"Micronesia, Federated States of\", dial_code: \"+691\", code: \"FM\" },\r\n    { name: \"Moldova, Republic of\", dial_code: \"+373\", code: \"MD\" },\r\n    { name: \"Monaco\", dial_code: \"+377\", code: \"MC\" },\r\n    { name: \"Mongolia\", dial_code: \"+976\", code: \"MN\" },\r\n    { name: \"Montenegro\", dial_code: \"+382\", code: \"ME\" },\r\n    { name: \"Montserrat\", dial_code: \"+1664\", code: \"MS\" },\r\n    { name: \"Morocco\", dial_code: \"+212\", code: \"MA\" },\r\n    { name: \"Mozambique\", dial_code: \"+258\", code: \"MZ\" },\r\n    { name: \"Myanmar\", dial_code: \"+95\", code: \"MM\" },\r\n    { name: \"Namibia\", dial_code: \"+264\", code: \"NA\" },\r\n    { name: \"Nauru\", dial_code: \"+674\", code: \"NR\" },\r\n    { name: \"Nepal\", dial_code: \"+977\", code: \"NP\" },\r\n    { name: \"Netherlands\", dial_code: \"+31\", code: \"NL\" },\r\n    { name: \"Netherlands Antilles\", dial_code: \"+599\", code: \"AN\" },\r\n    { name: \"New Caledonia\", dial_code: \"+687\", code: \"NC\" },\r\n    { name: \"New Zealand\", dial_code: \"+64\", code: \"NZ\" },\r\n    { name: \"Nicaragua\", dial_code: \"+505\", code: \"NI\" },\r\n    { name: \"Niger\", dial_code: \"+227\", code: \"NE\" },\r\n    { name: \"Nigeria\", dial_code: \"+234\", code: \"NG\" },\r\n    { name: \"Niue\", dial_code: \"+683\", code: \"NU\" },\r\n    { name: \"Norfolk Island\", dial_code: \"+672\", code: \"NF\" },\r\n    { name: \"Northern Mariana Islands\", dial_code: \"+1 670\", code: \"MP\" },\r\n    { name: \"Norway\", dial_code: \"+47\", code: \"NO\" },\r\n    { name: \"Oman\", dial_code: \"+968\", code: \"OM\" },\r\n    { name: \"Pakistan\", dial_code: \"+92\", code: \"PK\" },\r\n    { name: \"Palau\", dial_code: \"+680\", code: \"PW\" },\r\n    { name: \"Palestinian Territory, Occupied\", dial_code: \"+970\", code: \"PS\" },\r\n    { name: \"Panama\", dial_code: \"+507\", code: \"PA\" },\r\n    { name: \"Papua New Guinea\", dial_code: \"+675\", code: \"PG\" },\r\n    { name: \"Paraguay\", dial_code: \"+595\", code: \"PY\" },\r\n    { name: \"Peru\", dial_code: \"+51\", code: \"PE\" },\r\n    { name: \"Philippines\", dial_code: \"+63\", code: \"PH\" },\r\n    { name: \"Pitcairn\", dial_code: \"+872\", code: \"PN\" },\r\n    { name: \"Poland\", dial_code: \"+48\", code: \"PL\" },\r\n    { name: \"Portugal\", dial_code: \"+351\", code: \"PT\" },\r\n    { name: \"Puerto Rico\", dial_code: \"+1 939\", code: \"PR\" },\r\n    { name: \"Qatar\", dial_code: \"+974\", code: \"QA\" },\r\n    { name: \"Romania\", dial_code: \"+40\", code: \"RO\" },\r\n    { name: \"Russia\", dial_code: \"+7\", code: \"RU\" },\r\n    { name: \"Rwanda\", dial_code: \"+250\", code: \"RW\" },\r\n    { name: \"Réunion\", dial_code: \"+262\", code: \"RE\" },\r\n    { name: \"Saint Barthélemy\", dial_code: \"+590\", code: \"BL\" },\r\n    {\r\n        name: \"Saint Helena, Ascension and Tristan Da Cunha\",\r\n        dial_code: \"+290\",\r\n        code: \"SH\",\r\n    },\r\n    { name: \"Saint Kitts and Nevis\", dial_code: \"+1 869\", code: \"KN\" },\r\n    { name: \"Saint Lucia\", dial_code: \"+1 758\", code: \"LC\" },\r\n    { name: \"Saint Martin\", dial_code: \"+590\", code: \"MF\" },\r\n    { name: \"Saint Pierre and Miquelon\", dial_code: \"+508\", code: \"PM\" },\r\n    { name: \"Saint Vincent and the Grenadines\", dial_code: \"+1 784\", code: \"VC\" },\r\n    { name: \"Samoa\", dial_code: \"+685\", code: \"WS\" },\r\n    { name: \"San Marino\", dial_code: \"+378\", code: \"SM\" },\r\n    { name: \"Sao Tome and Principe\", dial_code: \"+239\", code: \"ST\" },\r\n    { name: \"Saudi Arabia\", dial_code: \"+966\", code: \"SA\" },\r\n    { name: \"Senegal\", dial_code: \"+221\", code: \"SN\" },\r\n    { name: \"Serbia\", dial_code: \"+381\", code: \"RS\" },\r\n    { name: \"Seychelles\", dial_code: \"+248\", code: \"SC\" },\r\n    { name: \"Sierra Leone\", dial_code: \"+232\", code: \"SL\" },\r\n    { name: \"Singapore\", dial_code: \"+65\", code: \"SG\" },\r\n    { name: \"Slovakia\", dial_code: \"+421\", code: \"SK\" },\r\n    { name: \"Slovenia\", dial_code: \"+386\", code: \"SI\" },\r\n    { name: \"Solomon Islands\", dial_code: \"+677\", code: \"SB\" },\r\n    { name: \"Somalia\", dial_code: \"+252\", code: \"SO\" },\r\n    { name: \"South Africa\", dial_code: \"+27\", code: \"ZA\" },\r\n    {\r\n        name: \"South Georgia and the South Sandwich Islands\",\r\n        dial_code: \"+500\",\r\n        code: \"GS\",\r\n    },\r\n    { name: \"Spain\", dial_code: \"+34\", code: \"ES\" },\r\n    { name: \"Sri Lanka\", dial_code: \"+94\", code: \"LK\" },\r\n    { name: \"Sudan\", dial_code: \"+249\", code: \"SD\" },\r\n    { name: \"Suriname\", dial_code: \"+597\", code: \"SR\" },\r\n    { name: \"Svalbard and Jan Mayen\", dial_code: \"+47\", code: \"SJ\" },\r\n    { name: \"Swaziland\", dial_code: \"+268\", code: \"SZ\" },\r\n    { name: \"Sweden\", dial_code: \"+46\", code: \"SE\" },\r\n    { name: \"Switzerland\", dial_code: \"+41\", code: \"CH\" },\r\n    { name: \"Syrian Arab Republic\", dial_code: \"+963\", code: \"SY\" },\r\n    { name: \"Taiwan, Province of China\", dial_code: \"+886\", code: \"TW\" },\r\n    { name: \"Tajikistan\", dial_code: \"+992\", code: \"TJ\" },\r\n    { name: \"Tanzania, United Republic of\", dial_code: \"+255\", code: \"TZ\" },\r\n    { name: \"Thailand\", dial_code: \"+66\", code: \"TH\" },\r\n    { name: \"Timor-Leste\", dial_code: \"+670\", code: \"TL\" },\r\n    { name: \"Togo\", dial_code: \"+228\", code: \"TG\" },\r\n    { name: \"Tokelau\", dial_code: \"+690\", code: \"TK\" },\r\n    { name: \"Tonga\", dial_code: \"+676\", code: \"TO\" },\r\n    { name: \"Trinidad and Tobago\", dial_code: \"+1 868\", code: \"TT\" },\r\n    { name: \"Tunisia\", dial_code: \"+216\", code: \"TN\" },\r\n    { name: \"Turkey\", dial_code: \"+90\", code: \"TR\" },\r\n    { name: \"Turkmenistan\", dial_code: \"+993\", code: \"TM\" },\r\n    { name: \"Turks and Caicos Islands\", dial_code: \"+1 649\", code: \"TC\" },\r\n    { name: \"Tuvalu\", dial_code: \"+688\", code: \"TV\" },\r\n    { name: \"Uganda\", dial_code: \"+256\", code: \"UG\" },\r\n    { name: \"Ukraine\", dial_code: \"+380\", code: \"UA\" },\r\n    { name: \"United Arab Emirates\", dial_code: \"+971\", code: \"AE\" },\r\n    { name: \"United Kingdom\", dial_code: \"+44\", code: \"GB\" },\r\n    { name: \"United States\", dial_code: \"+1\", code: \"US\" },\r\n    { name: \"Uruguay\", dial_code: \"+598\", code: \"UY\" },\r\n    { name: \"Uzbekistan\", dial_code: \"+998\", code: \"UZ\" },\r\n    { name: \"Vanuatu\", dial_code: \"+678\", code: \"VU\" },\r\n    { name: \"Venezuela, Bolivarian Republic of\", dial_code: \"+58\", code: \"VE\" },\r\n    { name: \"Viet Nam\", dial_code: \"+84\", code: \"VN\" },\r\n    { name: \"Virgin Islands, British\", dial_code: \"+1 284\", code: \"VG\" },\r\n    { name: \"Virgin Islands, U.S.\", dial_code: \"+1 340\", code: \"VI\" },\r\n    { name: \"Wallis and Futuna\", dial_code: \"+681\", code: \"WF\" },\r\n    { name: \"Yemen\", dial_code: \"+967\", code: \"YE\" },\r\n    { name: \"Zambia\", dial_code: \"+260\", code: \"ZM\" },\r\n    { name: \"Zimbabwe\", dial_code: \"+263\", code: \"ZW\" },\r\n    { name: \"Åland Islands\", dial_code: \"+358\", code: \"AX\" },\r\n];\r\n\n\n/***/ }),\n\n/***/ \"pxUr\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"a\", function() { return /* binding */ agm_core_AgmCoreModule; });\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ agm_core_AgmMap; });\n__webpack_require__.d(__webpack_exports__, \"c\", function() { return /* binding */ agm_core_AgmMarker; });\n__webpack_require__.d(__webpack_exports__, \"d\", function() { return /* binding */ agm_core_GoogleMapsAPIWrapper; });\n\n// UNUSED EXPORTS: AgmBicyclingLayer, AgmCircle, AgmDataLayer, AgmFitBounds, AgmFullscreenControl, AgmGeocoder, AgmInfoWindow, AgmKmlLayer, AgmMapTypeControl, AgmPanControl, AgmPolygon, AgmPolyline, AgmPolylineIcon, AgmPolylinePoint, AgmRectangle, AgmRotateControl, AgmScaleControl, AgmStreetViewControl, AgmTransitLayer, AgmZoomControl, CircleManager, DataLayerManager, FitBoundsAccessor, GoogleMapsScriptProtocol, InfoWindowManager, KmlLayerManager, LAZY_MAPS_API_CONFIG, LayerManager, LazyMapsAPILoader, MapsAPILoader, MarkerManager, NoOpMapsAPILoader, PolygonManager, PolylineManager, RectangleManager, coreDirectives, ɵa, ɵb, ɵc, ɵd, ɵe\n\n// CONCATENATED MODULE: ./node_modules/@agm/core/node_modules/tslib/tslib.es6.js\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js + 1 modules\nvar core = __webpack_require__(\"fXoL\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 2 modules\nvar Observable = __webpack_require__(\"HDdC\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js\nvar BehaviorSubject = __webpack_require__(\"2Vo4\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js + 6 modules\nvar from = __webpack_require__(\"Cfvw\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js + 1 modules\nvar timer = __webpack_require__(\"PqYM\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js + 1 modules\nvar AsyncAction = __webpack_require__(\"3N8a\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js\n\nclass QueueAction_QueueAction extends AsyncAction[\"a\" /* AsyncAction */] {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    schedule(state, delay = 0) {\n        if (delay > 0) {\n            return super.schedule(state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    }\n    execute(state, delay) {\n        return (delay > 0 || this.closed) ?\n            super.execute(state, delay) :\n            this._execute(state, delay);\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        return scheduler.flush(this);\n    }\n}\n//# sourceMappingURL=QueueAction.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js + 1 modules\nvar AsyncScheduler = __webpack_require__(\"IjjT\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js\n\nclass QueueScheduler_QueueScheduler extends AsyncScheduler[\"a\" /* AsyncScheduler */] {\n}\n//# sourceMappingURL=QueueScheduler.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/queue.js\n\n\nconst queue = /*@__PURE__*/ new QueueScheduler_QueueScheduler(QueueAction_QueueAction);\n//# sourceMappingURL=queue.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules\nvar Subscription = __webpack_require__(\"quSY\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js\nvar Subscriber = __webpack_require__(\"7o/Q\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/empty.js\nvar empty = __webpack_require__(\"EY2u\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js\nvar of = __webpack_require__(\"LRne\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/throwError.js\n\nfunction throwError(error, scheduler) {\n    if (!scheduler) {\n        return new Observable[\"a\" /* Observable */](subscriber => subscriber.error(error));\n    }\n    else {\n        return new Observable[\"a\" /* Observable */](subscriber => scheduler.schedule(dispatch, 0, { error, subscriber }));\n    }\n}\nfunction dispatch({ error, subscriber }) {\n    subscriber.error(error);\n}\n//# sourceMappingURL=throwError.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/Notification.js\n\n\n\nvar NotificationKind = /*@__PURE__*/ (function (NotificationKind) {\n    NotificationKind[\"NEXT\"] = \"N\";\n    NotificationKind[\"ERROR\"] = \"E\";\n    NotificationKind[\"COMPLETE\"] = \"C\";\n    return NotificationKind;\n})({});\nlet Notification_Notification = /*@__PURE__*/ (() => {\n    class Notification {\n        constructor(kind, value, error) {\n            this.kind = kind;\n            this.value = value;\n            this.error = error;\n            this.hasValue = kind === 'N';\n        }\n        observe(observer) {\n            switch (this.kind) {\n                case 'N':\n                    return observer.next && observer.next(this.value);\n                case 'E':\n                    return observer.error && observer.error(this.error);\n                case 'C':\n                    return observer.complete && observer.complete();\n            }\n        }\n        do(next, error, complete) {\n            const kind = this.kind;\n            switch (kind) {\n                case 'N':\n                    return next && next(this.value);\n                case 'E':\n                    return error && error(this.error);\n                case 'C':\n                    return complete && complete();\n            }\n        }\n        accept(nextOrObserver, error, complete) {\n            if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n                return this.observe(nextOrObserver);\n            }\n            else {\n                return this.do(nextOrObserver, error, complete);\n            }\n        }\n        toObservable() {\n            const kind = this.kind;\n            switch (kind) {\n                case 'N':\n                    return Object(of[\"a\" /* of */])(this.value);\n                case 'E':\n                    return throwError(this.error);\n                case 'C':\n                    return Object(empty[\"b\" /* empty */])();\n            }\n            throw new Error('unexpected notification kind value');\n        }\n        static createNext(value) {\n            if (typeof value !== 'undefined') {\n                return new Notification('N', value);\n            }\n            return Notification.undefinedValueNotification;\n        }\n        static createError(err) {\n            return new Notification('E', undefined, err);\n        }\n        static createComplete() {\n            return Notification.completeNotification;\n        }\n    }\n    Notification.completeNotification = /*@__PURE__*/ new Notification('C');\n    Notification.undefinedValueNotification = /*@__PURE__*/ new Notification('N', undefined);\n    return Notification;\n})();\n//# sourceMappingURL=Notification.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/observeOn.js\n\n\nfunction observeOn(scheduler, delay = 0) {\n    return function observeOnOperatorFunction(source) {\n        return source.lift(new ObserveOnOperator(scheduler, delay));\n    };\n}\nclass ObserveOnOperator {\n    constructor(scheduler, delay = 0) {\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new observeOn_ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    }\n}\nclass observeOn_ObserveOnSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination, scheduler, delay = 0) {\n        super(destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    static dispatch(arg) {\n        const { notification, destination } = arg;\n        notification.observe(destination);\n        this.unsubscribe();\n    }\n    scheduleMessage(notification) {\n        const destination = this.destination;\n        destination.add(this.scheduler.schedule(observeOn_ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    }\n    _next(value) {\n        this.scheduleMessage(Notification_Notification.createNext(value));\n    }\n    _error(err) {\n        this.scheduleMessage(Notification_Notification.createError(err));\n        this.unsubscribe();\n    }\n    _complete() {\n        this.scheduleMessage(Notification_Notification.createComplete());\n        this.unsubscribe();\n    }\n}\nclass ObserveOnMessage {\n    constructor(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n}\n//# sourceMappingURL=observeOn.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js\nvar ObjectUnsubscribedError = __webpack_require__(\"9ppp\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/SubjectSubscription.js\nvar SubjectSubscription = __webpack_require__(\"Ylt2\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/ReplaySubject.js\n\n\n\n\n\n\nclass ReplaySubject_ReplaySubject extends Subject[\"a\" /* Subject */] {\n    constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n        super();\n        this.scheduler = scheduler;\n        this._events = [];\n        this._infiniteTimeWindow = false;\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            this._infiniteTimeWindow = true;\n            this.next = this.nextInfiniteTimeWindow;\n        }\n        else {\n            this.next = this.nextTimeWindow;\n        }\n    }\n    nextInfiniteTimeWindow(value) {\n        const _events = this._events;\n        _events.push(value);\n        if (_events.length > this._bufferSize) {\n            _events.shift();\n        }\n        super.next(value);\n    }\n    nextTimeWindow(value) {\n        this._events.push(new ReplayEvent(this._getNow(), value));\n        this._trimBufferThenGetEvents();\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        const _infiniteTimeWindow = this._infiniteTimeWindow;\n        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        const scheduler = this.scheduler;\n        const len = _events.length;\n        let subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError[\"a\" /* ObjectUnsubscribedError */]();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription[\"a\" /* SubjectSubscription */](this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    }\n    _getNow() {\n        return (this.scheduler || queue).now();\n    }\n    _trimBufferThenGetEvents() {\n        const now = this._getNow();\n        const _bufferSize = this._bufferSize;\n        const _windowTime = this._windowTime;\n        const _events = this._events;\n        const eventsCount = _events.length;\n        let spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    }\n}\nclass ReplayEvent {\n    constructor(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n}\n//# sourceMappingURL=ReplaySubject.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/AsyncSubject.js\n\n\nclass AsyncSubject_AsyncSubject extends Subject[\"a\" /* Subject */] {\n    constructor() {\n        super(...arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    _subscribe(subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription[\"a\" /* Subscription */].EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription[\"a\" /* Subscription */].EMPTY;\n        }\n        return super._subscribe(subscriber);\n    }\n    next(value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    }\n    error(error) {\n        if (!this.hasCompleted) {\n            super.error(error);\n        }\n    }\n    complete() {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            super.next(this.value);\n        }\n        super.complete();\n    }\n}\n//# sourceMappingURL=AsyncSubject.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js\nvar map = __webpack_require__(\"lJxs\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/canReportError.js\nvar canReportError = __webpack_require__(\"8Qeq\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isArray.js\nvar isArray = __webpack_require__(\"DH7j\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isScheduler.js\nvar isScheduler = __webpack_require__(\"z+Ro\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/bindCallback.js\n\n\n\n\n\n\nfunction bindCallback(callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (Object(isScheduler[\"a\" /* isScheduler */])(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return (...args) => bindCallback(callbackFunc, scheduler)(...args).pipe(Object(map[\"a\" /* map */])((args) => Object(isArray[\"a\" /* isArray */])(args) ? resultSelector(...args) : resultSelector(args)));\n        }\n    }\n    return function (...args) {\n        const context = this;\n        let subject;\n        const params = {\n            context,\n            subject,\n            callbackFunc,\n            scheduler,\n        };\n        return new Observable[\"a\" /* Observable */](subscriber => {\n            if (!scheduler) {\n                if (!subject) {\n                    subject = new AsyncSubject_AsyncSubject();\n                    const handler = (...innerArgs) => {\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    };\n                    try {\n                        callbackFunc.apply(context, [...args, handler]);\n                    }\n                    catch (err) {\n                        if (Object(canReportError[\"a\" /* canReportError */])(subject)) {\n                            subject.error(err);\n                        }\n                        else {\n                            console.warn(err);\n                        }\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                const state = {\n                    args, subscriber, params,\n                };\n                return scheduler.schedule(bindCallback_dispatch, 0, state);\n            }\n        });\n    };\n}\nfunction bindCallback_dispatch(state) {\n    const self = this;\n    const { args, subscriber, params } = state;\n    const { callbackFunc, context, scheduler } = params;\n    let { subject } = params;\n    if (!subject) {\n        subject = params.subject = new AsyncSubject_AsyncSubject();\n        const handler = (...innerArgs) => {\n            const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n            this.add(scheduler.schedule(dispatchNext, 0, { value, subject }));\n        };\n        try {\n            callbackFunc.apply(context, [...args, handler]);\n        }\n        catch (err) {\n            subject.error(err);\n        }\n    }\n    this.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(state) {\n    const { value, subject } = state;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(state) {\n    const { err, subject } = state;\n    subject.error(err);\n}\n//# sourceMappingURL=bindCallback.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isFunction.js\nvar isFunction = __webpack_require__(\"n6bG\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEventPattern.js\n\n\n\n\nfunction fromEventPattern(addHandler, removeHandler, resultSelector) {\n    if (resultSelector) {\n        return fromEventPattern(addHandler, removeHandler).pipe(Object(map[\"a\" /* map */])(args => Object(isArray[\"a\" /* isArray */])(args) ? resultSelector(...args) : resultSelector(args)));\n    }\n    return new Observable[\"a\" /* Observable */](subscriber => {\n        const handler = (...e) => subscriber.next(e.length === 1 ? e[0] : e);\n        let retValue;\n        try {\n            retValue = addHandler(handler);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!Object(isFunction[\"a\" /* isFunction */])(removeHandler)) {\n            return undefined;\n        }\n        return () => removeHandler(handler, retValue);\n    });\n}\n//# sourceMappingURL=fromEventPattern.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js\nvar merge = __webpack_require__(\"VRyK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mergeMap.js\nvar mergeMap = __webpack_require__(\"5+tZ\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js\nvar OuterSubscriber = __webpack_require__(\"l7GE\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js\nvar subscribeToResult = __webpack_require__(\"ZUHj\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/sample.js\n\n\nfunction sample(notifier) {\n    return (source) => source.lift(new sample_SampleOperator(notifier));\n}\nclass sample_SampleOperator {\n    constructor(notifier) {\n        this.notifier = notifier;\n    }\n    call(subscriber, source) {\n        const sampleSubscriber = new sample_SampleSubscriber(subscriber);\n        const subscription = source.subscribe(sampleSubscriber);\n        subscription.add(Object(subscribeToResult[\"a\" /* subscribeToResult */])(sampleSubscriber, this.notifier));\n        return subscription;\n    }\n}\nclass sample_SampleSubscriber extends OuterSubscriber[\"a\" /* OuterSubscriber */] {\n    constructor() {\n        super(...arguments);\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.value = value;\n        this.hasValue = true;\n    }\n    notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.emitValue();\n    }\n    notifyComplete() {\n        this.emitValue();\n    }\n    emitValue() {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    }\n}\n//# sourceMappingURL=sample.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js\nvar switchMap = __webpack_require__(\"eIep\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js\n\nfunction shareReplay(configOrBufferSize, windowTime, scheduler) {\n    let config;\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        config = configOrBufferSize;\n    }\n    else {\n        config = {\n            bufferSize: configOrBufferSize,\n            windowTime,\n            refCount: false,\n            scheduler\n        };\n    }\n    return (source) => source.lift(shareReplayOperator(config));\n}\nfunction shareReplayOperator({ bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, refCount: useRefCount, scheduler }) {\n    let subject;\n    let refCount = 0;\n    let subscription;\n    let hasError = false;\n    let isComplete = false;\n    return function shareReplayOperation(source) {\n        refCount++;\n        if (!subject || hasError) {\n            hasError = false;\n            subject = new ReplaySubject_ReplaySubject(bufferSize, windowTime, scheduler);\n            subscription = source.subscribe({\n                next(value) { subject.next(value); },\n                error(err) {\n                    hasError = true;\n                    subject.error(err);\n                },\n                complete() {\n                    isComplete = true;\n                    subscription = undefined;\n                    subject.complete();\n                },\n            });\n        }\n        const innerSub = subject.subscribe(this);\n        this.add(() => {\n            refCount--;\n            innerSub.unsubscribe();\n            if (subscription && !isComplete && useRefCount && refCount === 0) {\n                subscription.unsubscribe();\n                subscription = undefined;\n                subject = undefined;\n            }\n        });\n    };\n}\n//# sourceMappingURL=shareReplay.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/multicast.js\nvar multicast = __webpack_require__(\"oB13\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js\nvar startWith = __webpack_require__(\"JX91\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/skip.js\n\nfunction skip(count) {\n    return (source) => source.lift(new SkipOperator(count));\n}\nclass SkipOperator {\n    constructor(total) {\n        this.total = total;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new skip_SkipSubscriber(subscriber, this.total));\n    }\n}\nclass skip_SkipSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination, total) {\n        super(destination);\n        this.total = total;\n        this.count = 0;\n    }\n    _next(x) {\n        if (++this.count > this.total) {\n            this.destination.next(x);\n        }\n    }\n}\n//# sourceMappingURL=skip.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js\nvar distinctUntilChanged = __webpack_require__(\"/uUt\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js\nvar takeUntil = __webpack_require__(\"1G5W\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// CONCATENATED MODULE: ./node_modules/@agm/core/__ivy_ngcc__/fesm2015/agm-core.js\n\n\n\n\n\n\nconst _c0 = [\"*\"];\nlet agm_core_MapsAPILoader = /*@__PURE__*/ (() => {\n    class MapsAPILoader {\n    }\n    MapsAPILoader.ɵfac = function MapsAPILoader_Factory(t) { return new (t || MapsAPILoader)(); };\n    MapsAPILoader.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: MapsAPILoader, factory: MapsAPILoader.ɵfac });\n    return MapsAPILoader;\n})();\nlet agm_core_GoogleMapsAPIWrapper = /*@__PURE__*/ (() => {\n    class GoogleMapsAPIWrapper {\n        constructor(_loader, _zone) {\n            this._loader = _loader;\n            this._zone = _zone;\n            this._map =\n                new Promise((resolve) => { this._mapResolver = resolve; });\n        }\n        createMap(el, mapOptions) {\n            return this._zone.runOutsideAngular(() => {\n                return this._loader.load().then(() => {\n                    const map = new google.maps.Map(el, mapOptions);\n                    this._mapResolver(map);\n                    return;\n                });\n            });\n        }\n        setMapOptions(options) {\n            return this._zone.runOutsideAngular(() => {\n                this._map.then((m) => { m.setOptions(options); });\n            });\n        }\n        /**\n         * Creates a google map marker with the map context\n         */\n        createMarker(options = {}, addToMap = true) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => {\n                    if (addToMap) {\n                        options.map = map;\n                    }\n                    return new google.maps.Marker(options);\n                });\n            });\n        }\n        createInfoWindow(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then(() => new google.maps.InfoWindow(options));\n            });\n        }\n        /**\n         * Creates a google.map.Circle for the current map.\n         */\n        createCircle(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => {\n                    options.map = map;\n                    return new google.maps.Circle(options);\n                });\n            });\n        }\n        /**\n         * Creates a google.map.Rectangle for the current map.\n         */\n        createRectangle(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => {\n                    options.map = map;\n                    return new google.maps.Rectangle(options);\n                });\n            });\n        }\n        createPolyline(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this.getNativeMap().then((map) => {\n                    const line = new google.maps.Polyline(options);\n                    line.setMap(map);\n                    return line;\n                });\n            });\n        }\n        createPolygon(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this.getNativeMap().then((map) => {\n                    const polygon = new google.maps.Polygon(options);\n                    polygon.setMap(map);\n                    return polygon;\n                });\n            });\n        }\n        /**\n         * Creates a new google.map.Data layer for the current map\n         */\n        createDataLayer(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then(m => {\n                    const data = new google.maps.Data(options);\n                    data.setMap(m);\n                    return data;\n                });\n            });\n        }\n        /**\n         * Creates a TransitLayer instance for a map\n         * @returns a new transit layer object\n         */\n        createTransitLayer() {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => {\n                    const newLayer = new google.maps.TransitLayer();\n                    newLayer.setMap(map);\n                    return newLayer;\n                });\n            });\n        }\n        /**\n         * Creates a BicyclingLayer instance for a map\n         * @returns a new bicycling layer object\n         */\n        createBicyclingLayer() {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => {\n                    const newLayer = new google.maps.BicyclingLayer();\n                    newLayer.setMap(map);\n                    return newLayer;\n                });\n            });\n        }\n        /**\n         * Determines if given coordinates are insite a Polygon path.\n         */\n        containsLocation(latLng, polygon) {\n            return this._map.then(() => google.maps.geometry.poly.containsLocation(latLng, polygon));\n        }\n        subscribeToMapEvent(eventName) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._map.then(m => m.addListener(eventName, () => this._zone.run(() => observer.next(arguments[0]))));\n            });\n        }\n        clearInstanceListeners() {\n            return this._zone.runOutsideAngular(() => {\n                this._map.then((map) => {\n                    google.maps.event.clearInstanceListeners(map);\n                });\n            });\n        }\n        setCenter(latLng) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.setCenter(latLng));\n            });\n        }\n        getZoom() {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.getZoom());\n            });\n        }\n        getBounds() {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.getBounds());\n            });\n        }\n        getMapTypeId() {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.getMapTypeId());\n            });\n        }\n        setZoom(zoom) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.setZoom(zoom));\n            });\n        }\n        getCenter() {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.getCenter());\n            });\n        }\n        panTo(latLng) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.panTo(latLng));\n            });\n        }\n        panBy(x, y) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.panBy(x, y));\n            });\n        }\n        fitBounds(latLng, padding) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.fitBounds(latLng, padding));\n            });\n        }\n        panToBounds(latLng, padding) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.panToBounds(latLng, padding));\n            });\n        }\n        /**\n         * Returns the native Google Maps Map instance. Be careful when using this instance directly.\n         */\n        getNativeMap() { return this._map; }\n        /**\n         * Triggers the given event name on the map instance.\n         */\n        triggerMapEvent(eventName) {\n            return this._map.then((m) => google.maps.event.trigger(m, eventName));\n        }\n    }\n    GoogleMapsAPIWrapper.ɵfac = function GoogleMapsAPIWrapper_Factory(t) { return new (t || GoogleMapsAPIWrapper)(core[\"ɵɵinject\"](agm_core_MapsAPILoader), core[\"ɵɵinject\"](core[\"NgZone\"])); };\n    GoogleMapsAPIWrapper.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: GoogleMapsAPIWrapper, factory: GoogleMapsAPIWrapper.ɵfac });\n    return GoogleMapsAPIWrapper;\n})();\nlet agm_core_CircleManager = /*@__PURE__*/ (() => {\n    class CircleManager {\n        constructor(_apiWrapper, _zone) {\n            this._apiWrapper = _apiWrapper;\n            this._zone = _zone;\n            this._circles = new Map();\n        }\n        addCircle(circle) {\n            this._apiWrapper.getNativeMap().then(() => this._circles.set(circle, this._apiWrapper.createCircle({\n                center: { lat: circle.latitude, lng: circle.longitude },\n                clickable: circle.clickable,\n                draggable: circle.draggable,\n                editable: circle.editable,\n                fillColor: circle.fillColor,\n                fillOpacity: circle.fillOpacity,\n                radius: circle.radius,\n                strokeColor: circle.strokeColor,\n                strokeOpacity: circle.strokeOpacity,\n                strokePosition: google.maps.StrokePosition[circle.strokePosition],\n                strokeWeight: circle.strokeWeight,\n                visible: circle.visible,\n                zIndex: circle.zIndex,\n            })));\n        }\n        /**\n         * Removes the given circle from the map.\n         */\n        removeCircle(circle) {\n            return this._circles.get(circle).then((c) => {\n                c.setMap(null);\n                this._circles.delete(circle);\n            });\n        }\n        setOptions(circle, options) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return this._circles.get(circle).then((c) => {\n                    const actualParam = options.strokePosition;\n                    options.strokePosition = google.maps.StrokePosition[actualParam];\n                    c.setOptions(options);\n                });\n            });\n        }\n        getBounds(circle) {\n            return this._circles.get(circle).then((c) => c.getBounds());\n        }\n        getCenter(circle) {\n            return this._circles.get(circle).then((c) => c.getCenter());\n        }\n        getRadius(circle) {\n            return this._circles.get(circle).then((c) => c.getRadius());\n        }\n        setCenter(circle) {\n            return this._circles.get(circle).then(c => c.setCenter({ lat: circle.latitude, lng: circle.longitude }));\n        }\n        setEditable(circle) {\n            return this._circles.get(circle).then(c => c.setEditable(circle.editable));\n        }\n        setDraggable(circle) {\n            return this._circles.get(circle).then(c => c.setDraggable(circle.draggable));\n        }\n        setVisible(circle) {\n            return this._circles.get(circle).then(c => c.setVisible(circle.visible));\n        }\n        setRadius(circle) {\n            return this._circles.get(circle).then(c => c.setRadius(circle.radius));\n        }\n        getNativeCircle(circle) {\n            return this._circles.get(circle);\n        }\n        createEventObservable(eventName, circle) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                let listener = null;\n                this._circles.get(circle).then((c) => {\n                    listener = c.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n                return () => {\n                    if (listener !== null) {\n                        listener.remove();\n                    }\n                };\n            });\n        }\n    }\n    CircleManager.ɵfac = function CircleManager_Factory(t) { return new (t || CircleManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper), core[\"ɵɵinject\"](core[\"NgZone\"])); };\n    CircleManager.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: CircleManager, factory: CircleManager.ɵfac });\n    return CircleManager;\n})();\nlet agm_core_DataLayerManager = /*@__PURE__*/ (() => {\n    class DataLayerManager {\n        constructor(_wrapper, _zone) {\n            this._wrapper = _wrapper;\n            this._zone = _zone;\n            this._layers = new Map();\n        }\n        /**\n         * Adds a new Data Layer to the map.\n         */\n        addDataLayer(layer) {\n            const newLayer = this._wrapper.createDataLayer({\n                style: layer.style,\n            })\n                .then(d => {\n                if (layer.geoJson) {\n                    // NOTE: accessing \"features\" on google.maps.Data is undocumented\n                    this.getDataFeatures(d, layer.geoJson).then(features => d.features = features);\n                }\n                return d;\n            });\n            this._layers.set(layer, newLayer);\n        }\n        deleteDataLayer(layer) {\n            this._layers.get(layer).then(l => {\n                l.setMap(null);\n                this._layers.delete(layer);\n            });\n        }\n        updateGeoJson(layer, geoJson) {\n            this._layers.get(layer).then(l => {\n                l.forEach(feature => {\n                    l.remove(feature);\n                    // NOTE: accessing \"features\" on google.maps.Data is undocumented\n                    const index = l.features.indexOf(feature, 0);\n                    if (index > -1) {\n                        l.features.splice(index, 1);\n                    }\n                });\n                this.getDataFeatures(l, geoJson).then(features => l.features = features);\n            });\n        }\n        setDataOptions(layer, options) {\n            this._layers.get(layer).then(l => {\n                l.setControlPosition(options.controlPosition);\n                l.setControls(options.controls);\n                l.setDrawingMode(options.drawingMode);\n                l.setStyle(options.style);\n            });\n        }\n        /**\n         * Creates a Google Maps event listener for the given DataLayer as an Observable\n         */\n        createEventObservable(eventName, layer) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._layers.get(layer).then((d) => {\n                    d.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n        /**\n         * Extract features from a geoJson using google.maps Data Class\n         * @param d : google.maps.Data class instance\n         * @param geoJson : url or geojson object\n         */\n        getDataFeatures(d, geoJson) {\n            return new Promise((resolve, reject) => {\n                if (typeof geoJson === 'object') {\n                    try {\n                        const features = d.addGeoJson(geoJson);\n                        resolve(features);\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                }\n                else if (typeof geoJson === 'string') {\n                    d.loadGeoJson(geoJson, null, resolve);\n                }\n                else {\n                    reject(`Impossible to extract features from geoJson: wrong argument type`);\n                }\n            });\n        }\n    }\n    DataLayerManager.ɵfac = function DataLayerManager_Factory(t) { return new (t || DataLayerManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper), core[\"ɵɵinject\"](core[\"NgZone\"])); };\n    DataLayerManager.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: DataLayerManager, factory: DataLayerManager.ɵfac });\n    return DataLayerManager;\n})();\n/**\n * Class to implement when you what to be able to make it work with the auto fit bounds feature\n * of AGM.\n */\nclass FitBoundsAccessor {\n}\nlet agm_core_FitBoundsService = /*@__PURE__*/ (() => {\n    class FitBoundsService {\n        constructor(loader) {\n            this._boundsChangeSampleTime$ = new BehaviorSubject[\"a\" /* BehaviorSubject */](200);\n            this._includeInBounds$ = new BehaviorSubject[\"a\" /* BehaviorSubject */](new Map());\n            this.bounds$ = Object(from[\"a\" /* from */])(loader.load()).pipe(Object(mergeMap[\"a\" /* mergeMap */])(() => this._includeInBounds$), sample(this._boundsChangeSampleTime$.pipe(Object(switchMap[\"a\" /* switchMap */])(time => Object(timer[\"a\" /* timer */])(0, time)))), Object(map[\"a\" /* map */])(includeInBounds => this._generateBounds(includeInBounds)), shareReplay(1));\n        }\n        _generateBounds(includeInBounds) {\n            const bounds = new google.maps.LatLngBounds();\n            includeInBounds.forEach(b => bounds.extend(b));\n            return bounds;\n        }\n        addToBounds(latLng) {\n            const id = this._createIdentifier(latLng);\n            if (this._includeInBounds$.value.has(id)) {\n                return;\n            }\n            const boundsMap = this._includeInBounds$.value;\n            boundsMap.set(id, latLng);\n            this._includeInBounds$.next(boundsMap);\n        }\n        removeFromBounds(latLng) {\n            const boundsMap = this._includeInBounds$.value;\n            boundsMap.delete(this._createIdentifier(latLng));\n            this._includeInBounds$.next(boundsMap);\n        }\n        changeFitBoundsChangeSampleTime(timeMs) {\n            this._boundsChangeSampleTime$.next(timeMs);\n        }\n        getBounds$() {\n            return this.bounds$;\n        }\n        _createIdentifier(latLng) {\n            return `${latLng.lat}+${latLng.lng}`;\n        }\n    }\n    FitBoundsService.ɵfac = function FitBoundsService_Factory(t) { return new (t || FitBoundsService)(core[\"ɵɵinject\"](agm_core_MapsAPILoader)); };\n    FitBoundsService.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: FitBoundsService, factory: FitBoundsService.ɵfac });\n    return FitBoundsService;\n})();\nlet agm_core_AgmGeocoder = /*@__PURE__*/ (() => {\n    class AgmGeocoder {\n        constructor(loader) {\n            const connectableGeocoder$ = new Observable[\"a\" /* Observable */](subscriber => {\n                loader.load().then(() => subscriber.next());\n            })\n                .pipe(Object(map[\"a\" /* map */])(() => this._createGeocoder()), Object(multicast[\"a\" /* multicast */])(new ReplaySubject_ReplaySubject(1)));\n            connectableGeocoder$.connect(); // ignore the subscription\n            // since we will remain subscribed till application exits\n            this.geocoder$ = connectableGeocoder$;\n        }\n        geocode(request) {\n            return this.geocoder$.pipe(Object(switchMap[\"a\" /* switchMap */])((geocoder) => this._getGoogleResults(geocoder, request)));\n        }\n        _getGoogleResults(geocoder, request) {\n            const geocodeObservable = bindCallback(geocoder.geocode);\n            return geocodeObservable(request).pipe(Object(switchMap[\"a\" /* switchMap */])(([results, status]) => {\n                if (status === google.maps.GeocoderStatus.OK) {\n                    return Object(of[\"a\" /* of */])(results);\n                }\n                return throwError(status);\n            }));\n        }\n        _createGeocoder() {\n            return new google.maps.Geocoder();\n        }\n    }\n    AgmGeocoder.ɵfac = function AgmGeocoder_Factory(t) { return new (t || AgmGeocoder)(core[\"ɵɵinject\"](agm_core_MapsAPILoader)); };\n    AgmGeocoder.ɵprov = Object(core[\"ɵɵdefineInjectable\"])({ factory: function AgmGeocoder_Factory() { return new AgmGeocoder(Object(core[\"ɵɵinject\"])(agm_core_MapsAPILoader)); }, token: AgmGeocoder, providedIn: \"root\" });\n    return AgmGeocoder;\n})();\nclass WindowRef {\n    getNativeWindow() { return window; }\n}\nclass DocumentRef {\n    getNativeDocument() { return document; }\n}\nconst BROWSER_GLOBALS_PROVIDERS = [WindowRef, DocumentRef];\nvar GoogleMapsScriptProtocol = /*@__PURE__*/ (function (GoogleMapsScriptProtocol) {\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"HTTP\"] = 1] = \"HTTP\";\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"HTTPS\"] = 2] = \"HTTPS\";\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"AUTO\"] = 3] = \"AUTO\";\n    return GoogleMapsScriptProtocol;\n})({});\n/**\n * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link\n * LazyMapsAPILoaderConfig}.\n */\nconst LAZY_MAPS_API_CONFIG = new core[\"InjectionToken\"]('angular-google-maps LAZY_MAPS_API_CONFIG');\nlet agm_core_LazyMapsAPILoader = /*@__PURE__*/ (() => {\n    class LazyMapsAPILoader extends agm_core_MapsAPILoader {\n        constructor(config = null, w, d, localeId) {\n            super();\n            this.localeId = localeId;\n            this._SCRIPT_ID = 'agmGoogleMapsApiScript';\n            this.callbackName = `agmLazyMapsAPILoader`;\n            this._config = config || {};\n            this._windowRef = w;\n            this._documentRef = d;\n        }\n        load() {\n            const window = this._windowRef.getNativeWindow();\n            if (window.google && window.google.maps) {\n                // Google maps already loaded on the page.\n                return Promise.resolve();\n            }\n            if (this._scriptLoadingPromise) {\n                return this._scriptLoadingPromise;\n            }\n            // this can happen in HMR situations or Stackblitz.io editors.\n            const scriptOnPage = this._documentRef.getNativeDocument().getElementById(this._SCRIPT_ID);\n            if (scriptOnPage) {\n                this._assignScriptLoadingPromise(scriptOnPage);\n                return this._scriptLoadingPromise;\n            }\n            const script = this._documentRef.getNativeDocument().createElement('script');\n            script.type = 'text/javascript';\n            script.async = true;\n            script.defer = true;\n            script.id = this._SCRIPT_ID;\n            script.src = this._getScriptSrc(this.callbackName);\n            this._assignScriptLoadingPromise(script);\n            this._documentRef.getNativeDocument().body.appendChild(script);\n            return this._scriptLoadingPromise;\n        }\n        _assignScriptLoadingPromise(scriptElem) {\n            this._scriptLoadingPromise = new Promise((resolve, reject) => {\n                this._windowRef.getNativeWindow()[this.callbackName] = () => {\n                    resolve();\n                };\n                scriptElem.onerror = (error) => {\n                    reject(error);\n                };\n            });\n        }\n        _getScriptSrc(callbackName) {\n            const protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;\n            let protocol;\n            switch (protocolType) {\n                case GoogleMapsScriptProtocol.AUTO:\n                    protocol = '';\n                    break;\n                case GoogleMapsScriptProtocol.HTTP:\n                    protocol = 'http:';\n                    break;\n                case GoogleMapsScriptProtocol.HTTPS:\n                    protocol = 'https:';\n                    break;\n            }\n            const hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';\n            const queryParams = {\n                v: this._config.apiVersion || 'quarterly',\n                callback: callbackName,\n                key: this._config.apiKey,\n                client: this._config.clientId,\n                channel: this._config.channel,\n                libraries: this._config.libraries,\n                region: this._config.region,\n                language: this._config.language || (this.localeId !== 'en-US' ? this.localeId : null),\n            };\n            const params = Object.keys(queryParams)\n                .filter((k) => queryParams[k] != null)\n                .filter((k) => {\n                // remove empty arrays\n                return !Array.isArray(queryParams[k]) ||\n                    (Array.isArray(queryParams[k]) && queryParams[k].length > 0);\n            })\n                .map((k) => {\n                // join arrays as comma seperated strings\n                const i = queryParams[k];\n                if (Array.isArray(i)) {\n                    return { key: k, value: i.join(',') };\n                }\n                return { key: k, value: queryParams[k] };\n            })\n                .map((entry) => {\n                return `${entry.key}=${entry.value}`;\n            })\n                .join('&');\n            return `${protocol}//${hostAndPath}?${params}`;\n        }\n    }\n    LazyMapsAPILoader.ɵfac = function LazyMapsAPILoader_Factory(t) { return new (t || LazyMapsAPILoader)(core[\"ɵɵinject\"](LAZY_MAPS_API_CONFIG, 8), core[\"ɵɵinject\"](WindowRef), core[\"ɵɵinject\"](DocumentRef), core[\"ɵɵinject\"](core[\"LOCALE_ID\"])); };\n    LazyMapsAPILoader.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: LazyMapsAPILoader, factory: LazyMapsAPILoader.ɵfac });\n    return LazyMapsAPILoader;\n})();\nlet agm_core_MarkerManager = /*@__PURE__*/ (() => {\n    class MarkerManager {\n        constructor(_mapsWrapper, _zone) {\n            this._mapsWrapper = _mapsWrapper;\n            this._zone = _zone;\n            this._markers = new Map();\n        }\n        convertAnimation(uiAnim) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (uiAnim === null) {\n                    return null;\n                }\n                else {\n                    return this._mapsWrapper.getNativeMap().then(() => google.maps.Animation[uiAnim]);\n                }\n            });\n        }\n        deleteMarker(markerDirective) {\n            const markerPromise = this._markers.get(markerDirective);\n            if (markerPromise == null) {\n                // marker already deleted\n                return Promise.resolve();\n            }\n            return markerPromise.then((marker) => {\n                return this._zone.run(() => {\n                    marker.setMap(null);\n                    this._markers.delete(markerDirective);\n                });\n            });\n        }\n        updateMarkerPosition(marker) {\n            return this._markers.get(marker).then((m) => m.setPosition({ lat: marker.latitude, lng: marker.longitude }));\n        }\n        updateTitle(marker) {\n            return this._markers.get(marker).then((m) => m.setTitle(marker.title));\n        }\n        updateLabel(marker) {\n            return this._markers.get(marker).then((m) => { m.setLabel(marker.label); });\n        }\n        updateDraggable(marker) {\n            return this._markers.get(marker).then((m) => m.setDraggable(marker.draggable));\n        }\n        updateIcon(marker) {\n            return this._markers.get(marker).then((m) => m.setIcon(marker.iconUrl));\n        }\n        updateOpacity(marker) {\n            return this._markers.get(marker).then((m) => m.setOpacity(marker.opacity));\n        }\n        updateVisible(marker) {\n            return this._markers.get(marker).then((m) => m.setVisible(marker.visible));\n        }\n        updateZIndex(marker) {\n            return this._markers.get(marker).then((m) => m.setZIndex(marker.zIndex));\n        }\n        updateClickable(marker) {\n            return this._markers.get(marker).then((m) => m.setClickable(marker.clickable));\n        }\n        updateAnimation(marker) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const m = yield this._markers.get(marker);\n                m.setAnimation(yield this.convertAnimation(marker.animation));\n            });\n        }\n        addMarker(marker) {\n            const markerPromise = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                return this._mapsWrapper.createMarker({\n                    position: { lat: marker.latitude, lng: marker.longitude },\n                    label: marker.label,\n                    draggable: marker.draggable,\n                    icon: marker.iconUrl,\n                    opacity: marker.opacity,\n                    visible: marker.visible,\n                    zIndex: marker.zIndex,\n                    title: marker.title,\n                    clickable: marker.clickable,\n                    animation: yield this.convertAnimation(marker.animation),\n                }).then(resolve);\n            }));\n            this._markers.set(marker, markerPromise);\n        }\n        getNativeMarker(marker) {\n            return this._markers.get(marker);\n        }\n        createEventObservable(eventName, marker) {\n            return new Observable[\"a\" /* Observable */](observer => {\n                this._markers.get(marker).then(m => m.addListener(eventName, e => this._zone.run(() => observer.next(e))));\n            });\n        }\n    }\n    MarkerManager.ɵfac = function MarkerManager_Factory(t) { return new (t || MarkerManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper), core[\"ɵɵinject\"](core[\"NgZone\"])); };\n    MarkerManager.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: MarkerManager, factory: MarkerManager.ɵfac });\n    return MarkerManager;\n})();\nlet agm_core_InfoWindowManager = /*@__PURE__*/ (() => {\n    class InfoWindowManager {\n        constructor(_mapsWrapper, _zone, _markerManager) {\n            this._mapsWrapper = _mapsWrapper;\n            this._zone = _zone;\n            this._markerManager = _markerManager;\n            this._infoWindows = new Map();\n        }\n        deleteInfoWindow(infoWindow) {\n            const iWindow = this._infoWindows.get(infoWindow);\n            if (iWindow == null) {\n                // info window already deleted\n                return Promise.resolve();\n            }\n            return iWindow.then((i) => {\n                return this._zone.run(() => {\n                    i.close();\n                    this._infoWindows.delete(infoWindow);\n                });\n            });\n        }\n        setPosition(infoWindow) {\n            return this._infoWindows.get(infoWindow).then((i) => i.setPosition({\n                lat: infoWindow.latitude,\n                lng: infoWindow.longitude,\n            }));\n        }\n        setZIndex(infoWindow) {\n            return this._infoWindows.get(infoWindow)\n                .then((i) => i.setZIndex(infoWindow.zIndex));\n        }\n        open(infoWindow) {\n            return this._infoWindows.get(infoWindow).then((w) => {\n                if (infoWindow.hostMarker != null) {\n                    return this._markerManager.getNativeMarker(infoWindow.hostMarker).then((marker) => {\n                        return this._mapsWrapper.getNativeMap().then((map) => w.open(map, marker));\n                    });\n                }\n                return this._mapsWrapper.getNativeMap().then((map) => w.open(map));\n            });\n        }\n        close(infoWindow) {\n            return this._infoWindows.get(infoWindow).then((w) => w.close());\n        }\n        setOptions(infoWindow, options) {\n            return this._infoWindows.get(infoWindow).then((i) => i.setOptions(options));\n        }\n        addInfoWindow(infoWindow) {\n            const options = {\n                content: infoWindow.content,\n                maxWidth: infoWindow.maxWidth,\n                zIndex: infoWindow.zIndex,\n                disableAutoPan: infoWindow.disableAutoPan,\n            };\n            if (typeof infoWindow.latitude === 'number' && typeof infoWindow.longitude === 'number') {\n                options.position = { lat: infoWindow.latitude, lng: infoWindow.longitude };\n            }\n            const infoWindowPromise = this._mapsWrapper.createInfoWindow(options);\n            this._infoWindows.set(infoWindow, infoWindowPromise);\n        }\n        /**\n         * Creates a Google Maps event listener for the given InfoWindow as an Observable\n         */\n        createEventObservable(eventName, infoWindow) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._infoWindows.get(infoWindow).then((i) => {\n                    i.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n    }\n    InfoWindowManager.ɵfac = function InfoWindowManager_Factory(t) { return new (t || InfoWindowManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper), core[\"ɵɵinject\"](core[\"NgZone\"]), core[\"ɵɵinject\"](agm_core_MarkerManager)); };\n    InfoWindowManager.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: InfoWindowManager, factory: InfoWindowManager.ɵfac });\n    return InfoWindowManager;\n})();\nlet agm_core_KmlLayerManager = /*@__PURE__*/ (() => {\n    class KmlLayerManager {\n        constructor(_wrapper, _zone) {\n            this._wrapper = _wrapper;\n            this._zone = _zone;\n            this._layers = new Map();\n        }\n        /**\n         * Adds a new KML Layer to the map.\n         */\n        addKmlLayer(layer) {\n            const newLayer = this._wrapper.getNativeMap().then(m => {\n                return new google.maps.KmlLayer({\n                    clickable: layer.clickable,\n                    map: m,\n                    preserveViewport: layer.preserveViewport,\n                    screenOverlays: layer.screenOverlays,\n                    suppressInfoWindows: layer.suppressInfoWindows,\n                    url: layer.url,\n                    zIndex: layer.zIndex,\n                });\n            });\n            this._layers.set(layer, newLayer);\n        }\n        setOptions(layer, options) {\n            this._layers.get(layer).then(l => l.setOptions(options));\n        }\n        deleteKmlLayer(layer) {\n            this._layers.get(layer).then(l => {\n                l.setMap(null);\n                this._layers.delete(layer);\n            });\n        }\n        /**\n         * Creates a Google Maps event listener for the given KmlLayer as an Observable\n         */\n        createEventObservable(eventName, layer) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._layers.get(layer).then((m) => {\n                    m.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n    }\n    KmlLayerManager.ɵfac = function KmlLayerManager_Factory(t) { return new (t || KmlLayerManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper), core[\"ɵɵinject\"](core[\"NgZone\"])); };\n    KmlLayerManager.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: KmlLayerManager, factory: KmlLayerManager.ɵfac });\n    return KmlLayerManager;\n})();\nlet agm_core_LayerManager = /*@__PURE__*/ (() => {\n    class LayerManager {\n        constructor(_wrapper) {\n            this._wrapper = _wrapper;\n            this._layers = new Map();\n        }\n        /**\n         * Adds a transit layer to a map instance.\n         * @param layer - a TransitLayer object\n         * @param _options - TransitLayerOptions options\n         * @returns void\n         */\n        addTransitLayer(layer) {\n            const newLayer = this._wrapper.createTransitLayer();\n            this._layers.set(layer, newLayer);\n        }\n        /**\n         * Adds a bicycling layer to a map instance.\n         * @param layer - a bicycling layer object\n         * @param _options - BicyclingLayer options\n         * @returns void\n         */\n        addBicyclingLayer(layer) {\n            const newLayer = this._wrapper.createBicyclingLayer();\n            this._layers.set(layer, newLayer);\n        }\n        /**\n         * Deletes a map layer\n         * @param layer - the layer to delete\n         */\n        deleteLayer(layer) {\n            return this._layers.get(layer).then(currentLayer => {\n                currentLayer.setMap(null);\n                this._layers.delete(layer);\n            });\n        }\n    }\n    LayerManager.ɵfac = function LayerManager_Factory(t) { return new (t || LayerManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper)); };\n    LayerManager.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: LayerManager, factory: LayerManager.ɵfac });\n    return LayerManager;\n})();\n/**\n * When using the NoOpMapsAPILoader, the Google Maps API must be added to the page via a `<script>`\n * Tag.\n * It's important that the Google Maps API script gets loaded first on the page.\n */\nclass NoOpMapsAPILoader {\n    load() {\n        if (!window.google || !window.google.maps) {\n            throw new Error('Google Maps API not loaded on page. Make sure window.google.maps is available!');\n        }\n        return Promise.resolve();\n    }\n}\nfunction createMVCEventObservable(array) {\n    const eventNames = ['insert_at', 'remove_at', 'set_at'];\n    return fromEventPattern(handler => eventNames.map(eventName => array.addListener(eventName, (index, previous) => handler.apply(array, [{ newArr: array.getArray(), eventName, index, previous }]))), (_handler, evListeners) => evListeners.forEach(evListener => evListener.remove()));\n}\nclass MvcArrayMock {\n    constructor() {\n        this.vals = [];\n        this.listeners = {\n            remove_at: [],\n            insert_at: [],\n            set_at: [],\n        };\n    }\n    clear() {\n        for (let i = this.vals.length - 1; i >= 0; i--) {\n            this.removeAt(i);\n        }\n    }\n    getArray() {\n        return [...this.vals];\n    }\n    getAt(i) {\n        return this.vals[i];\n    }\n    getLength() {\n        return this.vals.length;\n    }\n    insertAt(i, elem) {\n        this.vals.splice(i, 0, elem);\n        this.listeners.insert_at.forEach(listener => listener(i));\n    }\n    pop() {\n        const deleted = this.vals.pop();\n        this.listeners.remove_at.forEach(listener => listener(this.vals.length, deleted));\n        return deleted;\n    }\n    push(elem) {\n        this.vals.push(elem);\n        this.listeners.insert_at.forEach(listener => listener(this.vals.length - 1));\n        return this.vals.length;\n    }\n    removeAt(i) {\n        const deleted = this.vals.splice(i, 1)[0];\n        this.listeners.remove_at.forEach(listener => listener(i, deleted));\n        return deleted;\n    }\n    setAt(i, elem) {\n        const deleted = this.vals[i];\n        this.vals[i] = elem;\n        this.listeners.set_at.forEach(listener => listener(i, deleted));\n    }\n    forEach(callback) {\n        this.vals.forEach(callback);\n    }\n    addListener(eventName, handler) {\n        const listenerArr = this.listeners[eventName];\n        listenerArr.push(handler);\n        return {\n            remove: () => {\n                listenerArr.splice(listenerArr.indexOf(handler), 1);\n            },\n        };\n    }\n    bindTo() { throw new Error('Not implemented'); }\n    changed() { throw new Error('Not implemented'); }\n    get() { throw new Error('Not implemented'); }\n    notify() { throw new Error('Not implemented'); }\n    set() { throw new Error('Not implemented'); }\n    setValues() { throw new Error('Not implemented'); }\n    unbind() { throw new Error('Not implemented'); }\n    unbindAll() { throw new Error('Not implemented'); }\n}\nlet agm_core_PolygonManager = /*@__PURE__*/ (() => {\n    class PolygonManager {\n        constructor(_mapsWrapper, _zone) {\n            this._mapsWrapper = _mapsWrapper;\n            this._zone = _zone;\n            this._polygons = new Map();\n        }\n        addPolygon(path) {\n            const polygonPromise = this._mapsWrapper.createPolygon({\n                clickable: path.clickable,\n                draggable: path.draggable,\n                editable: path.editable,\n                fillColor: path.fillColor,\n                fillOpacity: path.fillOpacity,\n                geodesic: path.geodesic,\n                paths: path.paths,\n                strokeColor: path.strokeColor,\n                strokeOpacity: path.strokeOpacity,\n                strokeWeight: path.strokeWeight,\n                visible: path.visible,\n                zIndex: path.zIndex,\n            });\n            this._polygons.set(path, polygonPromise);\n        }\n        updatePolygon(polygon) {\n            const m = this._polygons.get(polygon);\n            if (m == null) {\n                return Promise.resolve();\n            }\n            return m.then((l) => this._zone.run(() => { l.setPaths(polygon.paths); }));\n        }\n        setPolygonOptions(path, options) {\n            return this._polygons.get(path).then((l) => { l.setOptions(options); });\n        }\n        deletePolygon(paths) {\n            const m = this._polygons.get(paths);\n            if (m == null) {\n                return Promise.resolve();\n            }\n            return m.then((l) => {\n                return this._zone.run(() => {\n                    l.setMap(null);\n                    this._polygons.delete(paths);\n                });\n            });\n        }\n        getPath(polygonDirective) {\n            return this._polygons.get(polygonDirective)\n                .then((polygon) => polygon.getPath().getArray());\n        }\n        getPaths(polygonDirective) {\n            return this._polygons.get(polygonDirective)\n                .then((polygon) => polygon.getPaths().getArray().map((p) => p.getArray()));\n        }\n        createEventObservable(eventName, path) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._polygons.get(path).then((l) => {\n                    l.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n        createPathEventObservable(agmPolygon) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const polygon = yield this._polygons.get(agmPolygon);\n                const paths = polygon.getPaths();\n                const pathsChanges$ = createMVCEventObservable(paths);\n                return pathsChanges$.pipe(Object(startWith[\"a\" /* startWith */])({ newArr: paths.getArray() }), // in order to subscribe to them all\n                Object(switchMap[\"a\" /* switchMap */])(parentMVEvent => Object(merge[\"a\" /* merge */])(... // rest parameter\n                parentMVEvent.newArr.map((chMVC, index) => createMVCEventObservable(chMVC)\n                    .pipe(Object(map[\"a\" /* map */])(chMVCEvent => ({ parentMVEvent, chMVCEvent, pathIndex: index })))))\n                    .pipe(// start the merged ob with an event signinifing change to parent\n                Object(startWith[\"a\" /* startWith */])({ parentMVEvent, chMVCEvent: null, pathIndex: null }))), skip(1), // skip the manually added event\n                Object(map[\"a\" /* map */])(({ parentMVEvent, chMVCEvent, pathIndex }) => {\n                    let retVal;\n                    if (!chMVCEvent) {\n                        retVal = {\n                            newArr: parentMVEvent.newArr.map(subArr => subArr.getArray().map(latLng => latLng.toJSON())),\n                            eventName: parentMVEvent.eventName,\n                            index: parentMVEvent.index,\n                        };\n                        if (parentMVEvent.previous) {\n                            retVal.previous = parentMVEvent.previous.getArray();\n                        }\n                    }\n                    else {\n                        retVal = {\n                            newArr: parentMVEvent.newArr.map(subArr => subArr.getArray().map(latLng => latLng.toJSON())),\n                            pathIndex,\n                            eventName: chMVCEvent.eventName,\n                            index: chMVCEvent.index,\n                        };\n                        if (chMVCEvent.previous) {\n                            retVal.previous = chMVCEvent.previous;\n                        }\n                    }\n                    return retVal;\n                }));\n            });\n        }\n    }\n    PolygonManager.ɵfac = function PolygonManager_Factory(t) { return new (t || PolygonManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper), core[\"ɵɵinject\"](core[\"NgZone\"])); };\n    PolygonManager.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: PolygonManager, factory: PolygonManager.ɵfac });\n    return PolygonManager;\n})();\nlet agm_core_PolylineManager = /*@__PURE__*/ (() => {\n    class PolylineManager {\n        constructor(_mapsWrapper, _zone) {\n            this._mapsWrapper = _mapsWrapper;\n            this._zone = _zone;\n            this._polylines = new Map();\n        }\n        static _convertPoints(line) {\n            const path = line._getPoints().map((point) => {\n                return { lat: point.latitude, lng: point.longitude };\n            });\n            return path;\n        }\n        static _convertPath(path) {\n            const symbolPath = google.maps.SymbolPath[path];\n            if (typeof symbolPath === 'number') {\n                return symbolPath;\n            }\n            else {\n                return path;\n            }\n        }\n        static _convertIcons(line) {\n            const icons = line._getIcons().map(agmIcon => ({\n                fixedRotation: agmIcon.fixedRotation,\n                offset: agmIcon.offset,\n                repeat: agmIcon.repeat,\n                icon: {\n                    anchor: new google.maps.Point(agmIcon.anchorX, agmIcon.anchorY),\n                    fillColor: agmIcon.fillColor,\n                    fillOpacity: agmIcon.fillOpacity,\n                    path: PolylineManager._convertPath(agmIcon.path),\n                    rotation: agmIcon.rotation,\n                    scale: agmIcon.scale,\n                    strokeColor: agmIcon.strokeColor,\n                    strokeOpacity: agmIcon.strokeOpacity,\n                    strokeWeight: agmIcon.strokeWeight,\n                },\n            }));\n            // prune undefineds;\n            icons.forEach(icon => {\n                Object.entries(icon).forEach(([key, val]) => {\n                    if (typeof val === 'undefined') {\n                        delete icon[key];\n                    }\n                });\n                if (typeof icon.icon.anchor.x === 'undefined' ||\n                    typeof icon.icon.anchor.y === 'undefined') {\n                    delete icon.icon.anchor;\n                }\n            });\n            return icons;\n        }\n        addPolyline(line) {\n            const polylinePromise = this._mapsWrapper.getNativeMap()\n                .then(() => [PolylineManager._convertPoints(line),\n                PolylineManager._convertIcons(line)])\n                .then(([path, icons]) => this._mapsWrapper.createPolyline({\n                clickable: line.clickable,\n                draggable: line.draggable,\n                editable: line.editable,\n                geodesic: line.geodesic,\n                strokeColor: line.strokeColor,\n                strokeOpacity: line.strokeOpacity,\n                strokeWeight: line.strokeWeight,\n                visible: line.visible,\n                zIndex: line.zIndex,\n                path,\n                icons,\n            }));\n            this._polylines.set(line, polylinePromise);\n        }\n        updatePolylinePoints(line) {\n            const path = PolylineManager._convertPoints(line);\n            const m = this._polylines.get(line);\n            if (m == null) {\n                return Promise.resolve();\n            }\n            return m.then((l) => this._zone.run(() => l.setPath(path)));\n        }\n        updateIconSequences(line) {\n            return __awaiter(this, void 0, void 0, function* () {\n                yield this._mapsWrapper.getNativeMap();\n                const icons = PolylineManager._convertIcons(line);\n                const m = this._polylines.get(line);\n                if (m == null) {\n                    return;\n                }\n                return m.then(l => this._zone.run(() => l.setOptions({ icons })));\n            });\n        }\n        setPolylineOptions(line, options) {\n            return this._polylines.get(line).then((l) => { l.setOptions(options); });\n        }\n        deletePolyline(line) {\n            const m = this._polylines.get(line);\n            if (m == null) {\n                return Promise.resolve();\n            }\n            return m.then((l) => {\n                return this._zone.run(() => {\n                    l.setMap(null);\n                    this._polylines.delete(line);\n                });\n            });\n        }\n        getMVCPath(agmPolyline) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const polyline = yield this._polylines.get(agmPolyline);\n                return polyline.getPath();\n            });\n        }\n        getPath(agmPolyline) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return (yield this.getMVCPath(agmPolyline)).getArray();\n            });\n        }\n        createEventObservable(eventName, line) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._polylines.get(line).then((l) => {\n                    l.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n        createPathEventObservable(line) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const mvcPath = yield this.getMVCPath(line);\n                return createMVCEventObservable(mvcPath);\n            });\n        }\n    }\n    PolylineManager.ɵfac = function PolylineManager_Factory(t) { return new (t || PolylineManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper), core[\"ɵɵinject\"](core[\"NgZone\"])); };\n    PolylineManager.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: PolylineManager, factory: PolylineManager.ɵfac });\n    return PolylineManager;\n})();\nlet agm_core_RectangleManager = /*@__PURE__*/ (() => {\n    class RectangleManager {\n        constructor(_apiWrapper, _zone) {\n            this._apiWrapper = _apiWrapper;\n            this._zone = _zone;\n            this._rectangles = new Map();\n        }\n        addRectangle(rectangle) {\n            this._apiWrapper.getNativeMap().then(() => this._rectangles.set(rectangle, this._apiWrapper.createRectangle({\n                bounds: {\n                    north: rectangle.north,\n                    east: rectangle.east,\n                    south: rectangle.south,\n                    west: rectangle.west,\n                },\n                clickable: rectangle.clickable,\n                draggable: rectangle.draggable,\n                editable: rectangle.editable,\n                fillColor: rectangle.fillColor,\n                fillOpacity: rectangle.fillOpacity,\n                strokeColor: rectangle.strokeColor,\n                strokeOpacity: rectangle.strokeOpacity,\n                strokePosition: google.maps.StrokePosition[rectangle.strokePosition],\n                strokeWeight: rectangle.strokeWeight,\n                visible: rectangle.visible,\n                zIndex: rectangle.zIndex,\n            })));\n        }\n        /**\n         * Removes the given rectangle from the map.\n         */\n        removeRectangle(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => {\n                r.setMap(null);\n                this._rectangles.delete(rectangle);\n            });\n        }\n        setOptions(rectangle, options) {\n            return this._rectangles.get(rectangle).then((r) => {\n                const actualStrokePosition = options.strokePosition;\n                options.strokePosition = google.maps.StrokePosition[actualStrokePosition];\n                r.setOptions(options);\n            });\n        }\n        getBounds(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => r.getBounds());\n        }\n        setBounds(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => {\n                return r.setBounds({\n                    north: rectangle.north,\n                    east: rectangle.east,\n                    south: rectangle.south,\n                    west: rectangle.west,\n                });\n            });\n        }\n        setEditable(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => {\n                return r.setEditable(rectangle.editable);\n            });\n        }\n        setDraggable(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => {\n                return r.setDraggable(rectangle.draggable);\n            });\n        }\n        setVisible(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => {\n                return r.setVisible(rectangle.visible);\n            });\n        }\n        createEventObservable(eventName, rectangle) {\n            return new Observable[\"a\" /* Observable */]((subsrciber) => {\n                let listener = null;\n                this._rectangles.get(rectangle).then((r) => {\n                    listener = r.addListener(eventName, (e) => this._zone.run(() => subsrciber.next(e)));\n                });\n                return () => {\n                    if (listener !== null) {\n                        listener.remove();\n                    }\n                };\n            });\n        }\n    }\n    RectangleManager.ɵfac = function RectangleManager_Factory(t) { return new (t || RectangleManager)(core[\"ɵɵinject\"](agm_core_GoogleMapsAPIWrapper), core[\"ɵɵinject\"](core[\"NgZone\"])); };\n    RectangleManager.ɵprov = core[\"ɵɵdefineInjectable\"]({ token: RectangleManager, factory: RectangleManager.ɵfac });\n    return RectangleManager;\n})();\nlet layerId = 0;\nlet agm_core_AgmBicyclingLayer = /*@__PURE__*/ (() => {\n    class AgmBicyclingLayer {\n        constructor(_manager) {\n            this._manager = _manager;\n            this._addedToManager = false;\n            this._id = (layerId++).toString();\n            /**\n             * Hide/show bicycling layer\n             */\n            this.visible = true;\n        }\n        ngOnInit() {\n            if (this._addedToManager) {\n                return;\n            }\n            this._manager.addBicyclingLayer(this);\n            this._addedToManager = true;\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return `AgmBicyclingLayer-${this._id.toString()}`; }\n        /** @internal */\n        ngOnDestroy() {\n            this._manager.deleteLayer(this);\n        }\n    }\n    AgmBicyclingLayer.ɵfac = function AgmBicyclingLayer_Factory(t) { return new (t || AgmBicyclingLayer)(core[\"ɵɵdirectiveInject\"](agm_core_LayerManager)); };\n    AgmBicyclingLayer.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmBicyclingLayer, selectors: [[\"agm-bicycling-layer\"]], inputs: { visible: \"visible\" } });\n    return AgmBicyclingLayer;\n})();\nlet agm_core_AgmCircle = /*@__PURE__*/ (() => {\n    class AgmCircle {\n        constructor(_manager) {\n            this._manager = _manager;\n            /**\n             * Indicates whether this Circle handles mouse events. Defaults to true.\n             */\n            this.clickable = true;\n            /**\n             * If set to true, the user can drag this circle over the map. Defaults to false.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = false;\n            /**\n             * If set to true, the user can edit this circle by dragging the control points shown at\n             * the center and around the circumference of the circle. Defaults to false.\n             */\n            this.editable = false;\n            /**\n             * The radius in meters on the Earth's surface.\n             */\n            this.radius = 0;\n            /**\n             * The stroke position. Defaults to CENTER.\n             * This property is not supported on Internet Explorer 8 and earlier.\n             */\n            this.strokePosition = 'CENTER';\n            /**\n             * The stroke width in pixels.\n             */\n            this.strokeWeight = 0;\n            /**\n             * Whether this circle is visible on the map. Defaults to true.\n             */\n            this.visible = true;\n            /**\n             * This event is fired when the circle's center is changed.\n             */\n            this.centerChange = new core[\"EventEmitter\"]();\n            /**\n             * This event emitter gets emitted when the user clicks on the circle.\n             */\n            this.circleClick = new core[\"EventEmitter\"]();\n            /**\n             * This event emitter gets emitted when the user clicks on the circle.\n             */\n            this.circleDblClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is repeatedly fired while the user drags the circle.\n             */\n            // tslint:disable-next-line: no-output-native\n            this.drag = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user stops dragging the circle.\n             */\n            this.dragEnd = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user starts dragging the circle.\n             */\n            this.dragStart = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM mousedown event is fired on the circle.\n             */\n            this.mouseDown = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM mousemove event is fired on the circle.\n             */\n            this.mouseMove = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired on circle mouseout.\n             */\n            this.mouseOut = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired on circle mouseover.\n             */\n            this.mouseOver = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM mouseup event is fired on the circle.\n             */\n            this.mouseUp = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the circle's radius is changed.\n             */\n            this.radiusChange = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the circle is right-clicked on.\n             */\n            this.rightClick = new core[\"EventEmitter\"]();\n            this._circleAddedToManager = false;\n            this._eventSubscriptions = [];\n        }\n        /** @internal */\n        ngOnInit() {\n            this._manager.addCircle(this);\n            this._circleAddedToManager = true;\n            this._registerEventListeners();\n        }\n        /** @internal */\n        ngOnChanges(changes) {\n            if (!this._circleAddedToManager) {\n                return;\n            }\n            // tslint:disable: no-string-literal\n            if (changes['latitude'] || changes['longitude']) {\n                this._manager.setCenter(this);\n            }\n            if (changes['editable']) {\n                this._manager.setEditable(this);\n            }\n            if (changes['draggable']) {\n                this._manager.setDraggable(this);\n            }\n            if (changes['visible']) {\n                this._manager.setVisible(this);\n            }\n            if (changes['radius']) {\n                this._manager.setRadius(this);\n            }\n            // tslint:enable: no-string-literal\n            this._updateCircleOptionsChanges(changes);\n        }\n        _updateCircleOptionsChanges(changes) {\n            const options = {};\n            const optionKeys = Object.keys(changes).filter(k => AgmCircle._mapOptions.indexOf(k) !== -1);\n            optionKeys.forEach((k) => { options[k] = changes[k].currentValue; });\n            if (optionKeys.length > 0) {\n                this._manager.setOptions(this, options);\n            }\n        }\n        _registerEventListeners() {\n            const events = new Map();\n            events.set('center_changed', this.centerChange);\n            events.set('click', this.circleClick);\n            events.set('dblclick', this.circleDblClick);\n            events.set('drag', this.drag);\n            events.set('dragend', this.dragEnd);\n            events.set('dragstart', this.dragStart);\n            events.set('mousedown', this.mouseDown);\n            events.set('mousemove', this.mouseMove);\n            events.set('mouseout', this.mouseOut);\n            events.set('mouseover', this.mouseOver);\n            events.set('mouseup', this.mouseUp);\n            events.set('radius_changed', this.radiusChange);\n            events.set('rightclick', this.rightClick);\n            events.forEach((eventEmitter, eventName) => {\n                this._eventSubscriptions.push(this._manager.createEventObservable(eventName, this).subscribe((value) => {\n                    switch (eventName) {\n                        case 'radius_changed':\n                            this._manager.getRadius(this).then((radius) => eventEmitter.emit(radius));\n                            break;\n                        case 'center_changed':\n                            this._manager.getCenter(this).then((center) => eventEmitter.emit({ lat: center.lat(), lng: center.lng() }));\n                            break;\n                        default:\n                            eventEmitter.emit(value);\n                    }\n                }));\n            });\n        }\n        /** @internal */\n        ngOnDestroy() {\n            this._eventSubscriptions.forEach(s => s.unsubscribe());\n            this._eventSubscriptions = null;\n            this._manager.removeCircle(this);\n        }\n        /**\n         * Gets the LatLngBounds of this Circle.\n         */\n        getBounds() { return this._manager.getBounds(this); }\n        getCenter() { return this._manager.getCenter(this); }\n    }\n    AgmCircle.ɵfac = function AgmCircle_Factory(t) { return new (t || AgmCircle)(core[\"ɵɵdirectiveInject\"](agm_core_CircleManager)); };\n    AgmCircle.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmCircle, selectors: [[\"agm-circle\"]], inputs: { clickable: \"clickable\", draggable: [\"circleDraggable\", \"draggable\"], editable: \"editable\", radius: \"radius\", strokePosition: \"strokePosition\", strokeWeight: \"strokeWeight\", visible: \"visible\", latitude: \"latitude\", longitude: \"longitude\", fillColor: \"fillColor\", fillOpacity: \"fillOpacity\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", zIndex: \"zIndex\" }, outputs: { centerChange: \"centerChange\", circleClick: \"circleClick\", circleDblClick: \"circleDblClick\", drag: \"drag\", dragEnd: \"dragEnd\", dragStart: \"dragStart\", mouseDown: \"mouseDown\", mouseMove: \"mouseMove\", mouseOut: \"mouseOut\", mouseOver: \"mouseOver\", mouseUp: \"mouseUp\", radiusChange: \"radiusChange\", rightClick: \"rightClick\" }, features: [core[\"ɵɵNgOnChangesFeature\"]] });\n    AgmCircle._mapOptions = [\n        'fillColor', 'fillOpacity', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight',\n        'visible', 'zIndex', 'clickable',\n    ];\n    return AgmCircle;\n})();\nlet layerId$1 = 0;\nlet agm_core_AgmDataLayer = /*@__PURE__*/ (() => {\n    class AgmDataLayer {\n        constructor(_manager) {\n            this._manager = _manager;\n            this._addedToManager = false;\n            this._id = (layerId$1++).toString();\n            this._subscriptions = [];\n            /**\n             * This event is fired when a feature in the layer is clicked.\n             */\n            this.layerClick = new core[\"EventEmitter\"]();\n            /**\n             * The geoJson to be displayed\n             */\n            this.geoJson = null;\n        }\n        ngOnInit() {\n            if (this._addedToManager) {\n                return;\n            }\n            this._manager.addDataLayer(this);\n            this._addedToManager = true;\n            this._addEventListeners();\n        }\n        _addEventListeners() {\n            const listeners = [\n                { name: 'click', handler: (ev) => this.layerClick.emit(ev) },\n            ];\n            listeners.forEach((obj) => {\n                const os = this._manager.createEventObservable(obj.name, this).subscribe(obj.handler);\n                this._subscriptions.push(os);\n            });\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return `AgmDataLayer-${this._id.toString()}`; }\n        /** @internal */\n        ngOnDestroy() {\n            this._manager.deleteDataLayer(this);\n            // unsubscribe all registered observable subscriptions\n            this._subscriptions.forEach(s => s.unsubscribe());\n        }\n        /** @internal */\n        ngOnChanges(changes) {\n            if (!this._addedToManager) {\n                return;\n            }\n            // tslint:disable-next-line: no-string-literal\n            const geoJsonChange = changes['geoJson'];\n            if (geoJsonChange) {\n                this._manager.updateGeoJson(this, geoJsonChange.currentValue);\n            }\n            const dataOptions = AgmDataLayer._dataOptionsAttributes.reduce((options, k) => options[k] = changes.hasOwnProperty(k) ? changes[k].currentValue : this[k], {});\n            this._manager.setDataOptions(this, dataOptions);\n        }\n    }\n    AgmDataLayer.ɵfac = function AgmDataLayer_Factory(t) { return new (t || AgmDataLayer)(core[\"ɵɵdirectiveInject\"](agm_core_DataLayerManager)); };\n    AgmDataLayer.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmDataLayer, selectors: [[\"agm-data-layer\"]], inputs: { geoJson: \"geoJson\", style: \"style\" }, outputs: { layerClick: \"layerClick\" }, features: [core[\"ɵɵNgOnChangesFeature\"]] });\n    AgmDataLayer._dataOptionsAttributes = ['style'];\n    return AgmDataLayer;\n})();\nlet agm_core_AgmFitBounds = /*@__PURE__*/ (() => {\n    class AgmFitBounds {\n        constructor(_fitBoundsAccessor, _fitBoundsService) {\n            this._fitBoundsAccessor = _fitBoundsAccessor;\n            this._fitBoundsService = _fitBoundsService;\n            /**\n             * If the value is true, the element gets added to the bounds of the map.\n             * Default: true.\n             */\n            this.agmFitBounds = true;\n            this._destroyed$ = new Subject[\"a\" /* Subject */]();\n            this._latestFitBoundsDetails = null;\n        }\n        /**\n         * @internal\n         */\n        ngOnChanges() {\n            this._updateBounds();\n        }\n        /**\n         * @internal\n         */\n        ngOnInit() {\n            this._fitBoundsAccessor\n                .getFitBoundsDetails$()\n                .pipe(Object(distinctUntilChanged[\"a\" /* distinctUntilChanged */])((x, y) => x.latLng.lat === y.latLng.lat && x.latLng.lng === y.latLng.lng), Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed$))\n                .subscribe(details => this._updateBounds(details));\n        }\n        /*\n         Either the location changed, or visible status changed.\n         Possible state changes are\n         invisible -> visible\n         visible -> invisible\n         visible -> visible (new location)\n        */\n        _updateBounds(newFitBoundsDetails) {\n            // either visibility will change, or location, so remove the old one anyway\n            if (this._latestFitBoundsDetails) {\n                this._fitBoundsService.removeFromBounds(this._latestFitBoundsDetails.latLng);\n                // don't set latestFitBoundsDetails to null, because we can toggle visibility from\n                // true -> false -> true, in which case we still need old value cached here\n            }\n            if (newFitBoundsDetails) {\n                this._latestFitBoundsDetails = newFitBoundsDetails;\n            }\n            if (!this._latestFitBoundsDetails) {\n                return;\n            }\n            if (this.agmFitBounds === true) {\n                this._fitBoundsService.addToBounds(this._latestFitBoundsDetails.latLng);\n            }\n        }\n        /**\n         * @internal\n         */\n        ngOnDestroy() {\n            this._destroyed$.next();\n            this._destroyed$.complete();\n            if (this._latestFitBoundsDetails !== null) {\n                this._fitBoundsService.removeFromBounds(this._latestFitBoundsDetails.latLng);\n            }\n        }\n    }\n    AgmFitBounds.ɵfac = function AgmFitBounds_Factory(t) { return new (t || AgmFitBounds)(core[\"ɵɵdirectiveInject\"](FitBoundsAccessor, 2), core[\"ɵɵdirectiveInject\"](agm_core_FitBoundsService)); };\n    AgmFitBounds.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmFitBounds, selectors: [[\"\", \"agmFitBounds\", \"\"]], inputs: { agmFitBounds: \"agmFitBounds\" }, features: [core[\"ɵɵNgOnChangesFeature\"]] });\n    return AgmFitBounds;\n})();\nlet infoWindowId = 0;\nlet agm_core_AgmInfoWindow = /*@__PURE__*/ (() => {\n    class AgmInfoWindow {\n        constructor(_infoWindowManager, _el) {\n            this._infoWindowManager = _infoWindowManager;\n            this._el = _el;\n            /**\n             * Sets the open state for the InfoWindow. You can also call the open() and close() methods.\n             */\n            this.isOpen = false;\n            /**\n             * Emits an event when the info window is closed.\n             */\n            this.infoWindowClose = new core[\"EventEmitter\"]();\n            this._infoWindowAddedToManager = false;\n            this._id = (infoWindowId++).toString();\n        }\n        ngOnInit() {\n            this.content = this._el.nativeElement.querySelector('.agm-info-window-content');\n            this._infoWindowManager.addInfoWindow(this);\n            this._infoWindowAddedToManager = true;\n            this._updateOpenState();\n            this._registerEventListeners();\n        }\n        /** @internal */\n        ngOnChanges(changes) {\n            if (!this._infoWindowAddedToManager) {\n                return;\n            }\n            // tslint:disable: no-string-literal\n            if ((changes['latitude'] || changes['longitude']) && typeof this.latitude === 'number' &&\n                typeof this.longitude === 'number') {\n                this._infoWindowManager.setPosition(this);\n            }\n            if (changes['zIndex']) {\n                this._infoWindowManager.setZIndex(this);\n            }\n            if (changes['isOpen']) {\n                this._updateOpenState();\n            }\n            this._setInfoWindowOptions(changes);\n        }\n        // tslint:enable: no-string-literal\n        _registerEventListeners() {\n            this._infoWindowManager.createEventObservable('closeclick', this).subscribe(() => {\n                this.isOpen = false;\n                this.infoWindowClose.emit();\n            });\n        }\n        _updateOpenState() {\n            this.isOpen ? this.open() : this.close();\n        }\n        _setInfoWindowOptions(changes) {\n            const options = {};\n            const optionKeys = Object.keys(changes).filter(k => AgmInfoWindow._infoWindowOptionsInputs.indexOf(k) !== -1);\n            optionKeys.forEach((k) => { options[k] = changes[k].currentValue; });\n            this._infoWindowManager.setOptions(this, options);\n        }\n        /**\n         * Opens the info window.\n         */\n        open() { return this._infoWindowManager.open(this); }\n        /**\n         * Closes the info window.\n         */\n        close() {\n            return this._infoWindowManager.close(this).then(() => { this.infoWindowClose.emit(); });\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return 'AgmInfoWindow-' + this._id.toString(); }\n        /** @internal */\n        ngOnDestroy() { this._infoWindowManager.deleteInfoWindow(this); }\n    }\n    AgmInfoWindow.ɵfac = function AgmInfoWindow_Factory(t) { return new (t || AgmInfoWindow)(core[\"ɵɵdirectiveInject\"](agm_core_InfoWindowManager), core[\"ɵɵdirectiveInject\"](core[\"ElementRef\"])); };\n    AgmInfoWindow.ɵcmp = core[\"ɵɵdefineComponent\"]({ type: AgmInfoWindow, selectors: [[\"agm-info-window\"]], inputs: { isOpen: \"isOpen\", latitude: \"latitude\", longitude: \"longitude\", disableAutoPan: \"disableAutoPan\", zIndex: \"zIndex\", maxWidth: \"maxWidth\" }, outputs: { infoWindowClose: \"infoWindowClose\" }, features: [core[\"ɵɵNgOnChangesFeature\"]], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[1, \"agm-info-window-content\"]], template: function AgmInfoWindow_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"ɵɵprojectionDef\"]();\n                core[\"ɵɵelementStart\"](0, \"div\", 0);\n                core[\"ɵɵprojection\"](1);\n                core[\"ɵɵelementEnd\"]();\n            }\n        }, encapsulation: 2 });\n    AgmInfoWindow._infoWindowOptionsInputs = ['disableAutoPan', 'maxWidth'];\n    return AgmInfoWindow;\n})();\nlet layerId$2 = 0;\nlet agm_core_AgmKmlLayer = /*@__PURE__*/ (() => {\n    class AgmKmlLayer {\n        constructor(_manager) {\n            this._manager = _manager;\n            this._addedToManager = false;\n            this._id = (layerId$2++).toString();\n            this._subscriptions = [];\n            /**\n             * If true, the layer receives mouse events. Default value is true.\n             */\n            this.clickable = true;\n            /**\n             * By default, the input map is centered and zoomed to the bounding box of the contents of the\n             * layer.\n             * If this option is set to true, the viewport is left unchanged, unless the map's center and zoom\n             * were never set.\n             */\n            this.preserveViewport = false;\n            /**\n             * Whether to render the screen overlays. Default true.\n             */\n            this.screenOverlays = true;\n            /**\n             * Suppress the rendering of info windows when layer features are clicked.\n             */\n            this.suppressInfoWindows = false;\n            /**\n             * The URL of the KML document to display.\n             */\n            this.url = null;\n            /**\n             * The z-index of the layer.\n             */\n            this.zIndex = null;\n            /**\n             * This event is fired when a feature in the layer is clicked.\n             */\n            this.layerClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the KML layers default viewport has changed.\n             */\n            this.defaultViewportChange = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the KML layer has finished loading.\n             * At this point it is safe to read the status property to determine if the layer loaded\n             * successfully.\n             */\n            this.statusChange = new core[\"EventEmitter\"]();\n        }\n        ngOnInit() {\n            if (this._addedToManager) {\n                return;\n            }\n            this._manager.addKmlLayer(this);\n            this._addedToManager = true;\n            this._addEventListeners();\n        }\n        ngOnChanges(changes) {\n            if (!this._addedToManager) {\n                return;\n            }\n            this._updatePolygonOptions(changes);\n        }\n        _updatePolygonOptions(changes) {\n            const options = Object.keys(changes)\n                .filter(k => AgmKmlLayer._kmlLayerOptions.indexOf(k) !== -1)\n                .reduce((obj, k) => {\n                obj[k] = changes[k].currentValue;\n                return obj;\n            }, {});\n            if (Object.keys(options).length > 0) {\n                this._manager.setOptions(this, options);\n            }\n        }\n        _addEventListeners() {\n            const listeners = [\n                { name: 'click', handler: (ev) => this.layerClick.emit(ev) },\n                { name: 'defaultviewport_changed', handler: () => this.defaultViewportChange.emit() },\n                { name: 'status_changed', handler: () => this.statusChange.emit() },\n            ];\n            listeners.forEach((obj) => {\n                const os = this._manager.createEventObservable(obj.name, this).subscribe(obj.handler);\n                this._subscriptions.push(os);\n            });\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return `AgmKmlLayer-${this._id.toString()}`; }\n        /** @internal */\n        ngOnDestroy() {\n            this._manager.deleteKmlLayer(this);\n            // unsubscribe all registered observable subscriptions\n            this._subscriptions.forEach(s => s.unsubscribe());\n        }\n    }\n    AgmKmlLayer.ɵfac = function AgmKmlLayer_Factory(t) { return new (t || AgmKmlLayer)(core[\"ɵɵdirectiveInject\"](agm_core_KmlLayerManager)); };\n    AgmKmlLayer.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmKmlLayer, selectors: [[\"agm-kml-layer\"]], inputs: { clickable: \"clickable\", preserveViewport: \"preserveViewport\", screenOverlays: \"screenOverlays\", suppressInfoWindows: \"suppressInfoWindows\", url: \"url\", zIndex: \"zIndex\" }, outputs: { layerClick: \"layerClick\", defaultViewportChange: \"defaultViewportChange\", statusChange: \"statusChange\" }, features: [core[\"ɵɵNgOnChangesFeature\"]] });\n    AgmKmlLayer._kmlLayerOptions = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'];\n    return AgmKmlLayer;\n})();\nlet agm_core_AgmMapControl = /*@__PURE__*/ (() => {\n    class AgmMapControl {\n    }\n    AgmMapControl.ɵfac = function AgmMapControl_Factory(t) { return new (t || AgmMapControl)(); };\n    AgmMapControl.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmMapControl, inputs: { position: \"position\" } });\n    return AgmMapControl;\n})();\nlet agm_core_AgmFullscreenControl = /*@__PURE__*/ (() => {\n    class AgmFullscreenControl extends agm_core_AgmMapControl {\n        getOptions() {\n            return {\n                fullscreenControl: true,\n                fullscreenControlOptions: {\n                    position: this.position && google.maps.ControlPosition[this.position],\n                },\n            };\n        }\n    }\n    AgmFullscreenControl.ɵfac = function AgmFullscreenControl_Factory(t) { return ɵAgmFullscreenControl_BaseFactory(t || AgmFullscreenControl); };\n    AgmFullscreenControl.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmFullscreenControl, selectors: [[\"agm-fullscreen-control\"]], features: [core[\"ɵɵProvidersFeature\"]([{ provide: agm_core_AgmMapControl, useExisting: AgmFullscreenControl }]), core[\"ɵɵInheritDefinitionFeature\"]] });\n    return AgmFullscreenControl;\n})();\nconst ɵAgmFullscreenControl_BaseFactory = /*@__PURE__*/ core[\"ɵɵgetInheritedFactory\"](agm_core_AgmFullscreenControl);\nlet agm_core_AgmMapTypeControl = /*@__PURE__*/ (() => {\n    class AgmMapTypeControl extends agm_core_AgmMapControl {\n        getOptions() {\n            return {\n                mapTypeControl: true,\n                mapTypeControlOptions: {\n                    position: this.position && google.maps.ControlPosition[this.position],\n                    style: this.style && google.maps.MapTypeControlStyle[this.style],\n                    mapTypeIds: this.mapTypeIds && this.mapTypeIds.map(mapTypeId => google.maps.MapTypeId[mapTypeId]),\n                },\n            };\n        }\n    }\n    AgmMapTypeControl.ɵfac = function AgmMapTypeControl_Factory(t) { return ɵAgmMapTypeControl_BaseFactory(t || AgmMapTypeControl); };\n    AgmMapTypeControl.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmMapTypeControl, selectors: [[\"agm-map-type-control\"]], inputs: { mapTypeIds: \"mapTypeIds\", style: \"style\" }, features: [core[\"ɵɵProvidersFeature\"]([{ provide: agm_core_AgmMapControl, useExisting: AgmMapTypeControl }]), core[\"ɵɵInheritDefinitionFeature\"]] });\n    return AgmMapTypeControl;\n})();\nconst ɵAgmMapTypeControl_BaseFactory = /*@__PURE__*/ core[\"ɵɵgetInheritedFactory\"](agm_core_AgmMapTypeControl);\nlet agm_core_AgmPanControl = /*@__PURE__*/ (() => {\n    class AgmPanControl extends agm_core_AgmMapControl {\n        getOptions() {\n            return {\n                panControl: true,\n                panControlOptions: {\n                    position: this.position && google.maps.ControlPosition[this.position],\n                },\n            };\n        }\n    }\n    AgmPanControl.ɵfac = function AgmPanControl_Factory(t) { return ɵAgmPanControl_BaseFactory(t || AgmPanControl); };\n    AgmPanControl.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmPanControl, selectors: [[\"agm-pan-control\"]], features: [core[\"ɵɵProvidersFeature\"]([{ provide: agm_core_AgmMapControl, useExisting: AgmPanControl }]), core[\"ɵɵInheritDefinitionFeature\"]] });\n    return AgmPanControl;\n})();\nconst ɵAgmPanControl_BaseFactory = /*@__PURE__*/ core[\"ɵɵgetInheritedFactory\"](agm_core_AgmPanControl);\nlet agm_core_AgmRotateControl = /*@__PURE__*/ (() => {\n    class AgmRotateControl extends agm_core_AgmMapControl {\n        getOptions() {\n            return {\n                rotateControl: true,\n                rotateControlOptions: {\n                    position: this.position && google.maps.ControlPosition[this.position],\n                },\n            };\n        }\n    }\n    AgmRotateControl.ɵfac = function AgmRotateControl_Factory(t) { return ɵAgmRotateControl_BaseFactory(t || AgmRotateControl); };\n    AgmRotateControl.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmRotateControl, selectors: [[\"agm-rotate-control\"]], features: [core[\"ɵɵProvidersFeature\"]([{ provide: agm_core_AgmMapControl, useExisting: AgmRotateControl }]), core[\"ɵɵInheritDefinitionFeature\"]] });\n    return AgmRotateControl;\n})();\nconst ɵAgmRotateControl_BaseFactory = /*@__PURE__*/ core[\"ɵɵgetInheritedFactory\"](agm_core_AgmRotateControl);\nlet agm_core_AgmScaleControl = /*@__PURE__*/ (() => {\n    class AgmScaleControl extends agm_core_AgmMapControl {\n        getOptions() {\n            return {\n                scaleControl: true,\n            };\n        }\n    }\n    AgmScaleControl.ɵfac = function AgmScaleControl_Factory(t) { return ɵAgmScaleControl_BaseFactory(t || AgmScaleControl); };\n    AgmScaleControl.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmScaleControl, selectors: [[\"agm-scale-control\"]], features: [core[\"ɵɵProvidersFeature\"]([{ provide: agm_core_AgmMapControl, useExisting: AgmScaleControl }]), core[\"ɵɵInheritDefinitionFeature\"]] });\n    return AgmScaleControl;\n})();\nconst ɵAgmScaleControl_BaseFactory = /*@__PURE__*/ core[\"ɵɵgetInheritedFactory\"](agm_core_AgmScaleControl);\nlet agm_core_AgmStreetViewControl = /*@__PURE__*/ (() => {\n    class AgmStreetViewControl extends agm_core_AgmMapControl {\n        getOptions() {\n            return {\n                streetViewControl: true,\n                streetViewControlOptions: {\n                    position: this.position && google.maps.ControlPosition[this.position],\n                },\n            };\n        }\n    }\n    AgmStreetViewControl.ɵfac = function AgmStreetViewControl_Factory(t) { return ɵAgmStreetViewControl_BaseFactory(t || AgmStreetViewControl); };\n    AgmStreetViewControl.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmStreetViewControl, selectors: [[\"agm-street-view-control\"]], features: [core[\"ɵɵProvidersFeature\"]([{ provide: agm_core_AgmMapControl, useExisting: AgmStreetViewControl }]), core[\"ɵɵInheritDefinitionFeature\"]] });\n    return AgmStreetViewControl;\n})();\nconst ɵAgmStreetViewControl_BaseFactory = /*@__PURE__*/ core[\"ɵɵgetInheritedFactory\"](agm_core_AgmStreetViewControl);\nlet agm_core_AgmZoomControl = /*@__PURE__*/ (() => {\n    class AgmZoomControl extends agm_core_AgmMapControl {\n        getOptions() {\n            return {\n                zoomControl: true,\n                zoomControlOptions: {\n                    position: this.position && google.maps.ControlPosition[this.position],\n                    style: this.style && google.maps.ZoomControlStyle[this.style],\n                },\n            };\n        }\n    }\n    AgmZoomControl.ɵfac = function AgmZoomControl_Factory(t) { return ɵAgmZoomControl_BaseFactory(t || AgmZoomControl); };\n    AgmZoomControl.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmZoomControl, selectors: [[\"agm-zoom-control\"]], inputs: { style: \"style\" }, features: [core[\"ɵɵProvidersFeature\"]([{ provide: agm_core_AgmMapControl, useExisting: AgmZoomControl }]), core[\"ɵɵInheritDefinitionFeature\"]] });\n    return AgmZoomControl;\n})();\nconst ɵAgmZoomControl_BaseFactory = /*@__PURE__*/ core[\"ɵɵgetInheritedFactory\"](agm_core_AgmZoomControl);\nlet agm_core_AgmMap = /*@__PURE__*/ (() => {\n    class AgmMap {\n        constructor(_elem, _mapsWrapper, \n        // tslint:disable-next-line: ban-types\n        _platformId, _fitBoundsService, _zone) {\n            this._elem = _elem;\n            this._mapsWrapper = _mapsWrapper;\n            this._platformId = _platformId;\n            this._fitBoundsService = _fitBoundsService;\n            this._zone = _zone;\n            /**\n             * The longitude that defines the center of the map.\n             */\n            this.longitude = 0;\n            /**\n             * The latitude that defines the center of the map.\n             */\n            this.latitude = 0;\n            /**\n             * The zoom level of the map. The default zoom level is 8.\n             */\n            this.zoom = 8;\n            /**\n             * Enables/disables if map is draggable.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = true;\n            /**\n             * Enables/disables zoom and center on double click. Enabled by default.\n             */\n            this.disableDoubleClickZoom = false;\n            /**\n             * Enables/disables all default UI of the Google map. Please note: When the map is created, this\n             * value cannot get updated.\n             */\n            this.disableDefaultUI = false;\n            /**\n             * If false, disables scrollwheel zooming on the map. The scrollwheel is enabled by default.\n             */\n            this.scrollwheel = true;\n            /**\n             * If false, prevents the map from being controlled by the keyboard. Keyboard shortcuts are\n             * enabled by default.\n             */\n            this.keyboardShortcuts = true;\n            /**\n             * Styles to apply to each of the default map types. Note that for Satellite/Hybrid and Terrain\n             * modes, these styles will only apply to labels and geometry.\n             */\n            this.styles = [];\n            /**\n             * When true and the latitude and/or longitude values changes, the Google Maps panTo method is\n             * used to\n             * center the map. See: https://developers.google.com/maps/documentation/javascript/reference#Map\n             */\n            this.usePanning = false;\n            /**\n             * Sets the viewport to contain the given bounds.\n             * If this option to `true`, the bounds get automatically computed from all elements that use the {@link AgmFitBounds} directive.\n             */\n            this.fitBounds = false;\n            /**\n             * The map mapTypeId. Defaults to 'roadmap'.\n             */\n            this.mapTypeId = 'ROADMAP';\n            /**\n             * When false, map icons are not clickable. A map icon represents a point of interest,\n             * also known as a POI. By default map icons are clickable.\n             */\n            this.clickableIcons = true;\n            /**\n             * A map icon represents a point of interest, also known as a POI.\n             * When map icons are clickable by default, an info window is displayed.\n             * When this property is set to false, the info window will not be shown but the click event\n             * will still fire\n             */\n            this.showDefaultInfoWindow = true;\n            /**\n             * This setting controls how gestures on the map are handled.\n             * Allowed values:\n             * - 'cooperative' (Two-finger touch gestures pan and zoom the map. One-finger touch gestures are not handled by the map.)\n             * - 'greedy'      (All touch gestures pan or zoom the map.)\n             * - 'none'        (The map cannot be panned or zoomed by user gestures.)\n             * - 'auto'        [default] (Gesture handling is either cooperative or greedy, depending on whether the page is scrollable or not.\n             */\n            this.gestureHandling = 'auto';\n            /**\n             * Controls the automatic switching behavior for the angle of incidence of\n             * the map. The only allowed values are 0 and 45. The value 0 causes the map\n             * to always use a 0° overhead view regardless of the zoom level and\n             * viewport. The value 45 causes the tilt angle to automatically switch to\n             * 45 whenever 45° imagery is available for the current zoom level and\n             * viewport, and switch back to 0 whenever 45° imagery is not available\n             * (this is the default behavior). 45° imagery is only available for\n             * satellite and hybrid map types, within some locations, and at some zoom\n             * levels. Note: getTilt returns the current tilt angle, not the value\n             * specified by this option. Because getTilt and this option refer to\n             * different things, do not bind() the tilt property; doing so may yield\n             * unpredictable effects. (Default of AGM is 0 (disabled). Enable it with value 45.)\n             */\n            this.tilt = 0;\n            this._observableSubscriptions = [];\n            /**\n             * This event emitter gets emitted when the user clicks on the map (but not when they click on a\n             * marker or infoWindow).\n             */\n            // tslint:disable-next-line: max-line-length\n            this.mapClick = new core[\"EventEmitter\"]();\n            /**\n             * This event emitter gets emitted when the user right-clicks on the map (but not when they click\n             * on a marker or infoWindow).\n             */\n            this.mapRightClick = new core[\"EventEmitter\"]();\n            /**\n             * This event emitter gets emitted when the user double-clicks on the map (but not when they click\n             * on a marker or infoWindow).\n             */\n            this.mapDblClick = new core[\"EventEmitter\"]();\n            /**\n             * This event emitter is fired when the map center changes.\n             */\n            this.centerChange = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the viewport bounds have changed.\n             */\n            this.boundsChange = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the mapTypeId property changes.\n             */\n            this.mapTypeIdChange = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the map becomes idle after panning or zooming.\n             */\n            this.idle = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the zoom level has changed.\n             */\n            this.zoomChange = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the google map is fully initialized.\n             * You get the google.maps.Map instance as a result of this EventEmitter.\n             */\n            this.mapReady = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the visible tiles have finished loading.\n             */\n            this.tilesLoaded = new core[\"EventEmitter\"]();\n        }\n        /** @internal */\n        ngAfterContentInit() {\n            if (Object(common[\"r\" /* isPlatformServer */])(this._platformId)) {\n                // The code is running on the server, do nothing\n                return;\n            }\n            // todo: this should be solved with a new component and a viewChild decorator\n            const container = this._elem.nativeElement.querySelector('.agm-map-container-inner');\n            this._initMapInstance(container);\n        }\n        _initMapInstance(el) {\n            this._mapsWrapper.createMap(el, {\n                center: { lat: this.latitude || 0, lng: this.longitude || 0 },\n                zoom: this.zoom,\n                minZoom: this.minZoom,\n                maxZoom: this.maxZoom,\n                controlSize: this.controlSize,\n                disableDefaultUI: this.disableDefaultUI,\n                disableDoubleClickZoom: this.disableDoubleClickZoom,\n                scrollwheel: this.scrollwheel,\n                backgroundColor: this.backgroundColor,\n                draggable: this.draggable,\n                draggableCursor: this.draggableCursor,\n                draggingCursor: this.draggingCursor,\n                keyboardShortcuts: this.keyboardShortcuts,\n                styles: this.styles,\n                mapTypeId: this.mapTypeId.toLocaleLowerCase(),\n                clickableIcons: this.clickableIcons,\n                gestureHandling: this.gestureHandling,\n                tilt: this.tilt,\n                restriction: this.restriction,\n            })\n                .then(() => this._mapsWrapper.getNativeMap())\n                .then(map => this.mapReady.emit(map));\n            // register event listeners\n            this._handleMapCenterChange();\n            this._handleMapZoomChange();\n            this._handleMapMouseEvents();\n            this._handleBoundsChange();\n            this._handleMapTypeIdChange();\n            this._handleTilesLoadedEvent();\n            this._handleIdleEvent();\n            this._handleControlChange();\n        }\n        /** @internal */\n        ngOnDestroy() {\n            // unsubscribe all registered observable subscriptions\n            this._observableSubscriptions.forEach((s) => s.unsubscribe());\n            // remove all listeners from the map instance\n            this._mapsWrapper.clearInstanceListeners();\n            if (this._fitBoundsSubscription) {\n                this._fitBoundsSubscription.unsubscribe();\n            }\n        }\n        /* @internal */\n        ngOnChanges(changes) {\n            this._updateMapOptionsChanges(changes);\n            this._updatePosition(changes);\n        }\n        _updateMapOptionsChanges(changes) {\n            const options = {};\n            const optionKeys = Object.keys(changes).filter(k => AgmMap._mapOptionsAttributes.indexOf(k) !== -1);\n            optionKeys.forEach((k) => { options[k] = changes[k].currentValue; });\n            this._mapsWrapper.setMapOptions(options);\n        }\n        /**\n         * Triggers a resize event on the google map instance.\n         * When recenter is true, the of the google map gets called with the current lat/lng values or fitBounds value to recenter the map.\n         * Returns a promise that gets resolved after the event was triggered.\n         */\n        triggerResize(recenter = true) {\n            // Note: When we would trigger the resize event and show the map in the same turn (which is a\n            // common case for triggering a resize event), then the resize event would not\n            // work (to show the map), so we trigger the event in a timeout.\n            return new Promise((resolve) => {\n                setTimeout(() => {\n                    return this._mapsWrapper.triggerMapEvent('resize').then(() => {\n                        if (recenter) {\n                            this.fitBounds != null ? this._fitBounds() : this._setCenter();\n                        }\n                        resolve();\n                    });\n                });\n            });\n        }\n        _updatePosition(changes) {\n            // tslint:disable: no-string-literal\n            if (changes['latitude'] == null && changes['longitude'] == null &&\n                !changes['fitBounds']) {\n                // no position update needed\n                return;\n            }\n            // tslint:enable: no-string-literal\n            // we prefer fitBounds in changes\n            if ('fitBounds' in changes) {\n                this._fitBounds();\n                return;\n            }\n            if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {\n                return;\n            }\n            this._setCenter();\n        }\n        _setCenter() {\n            const newCenter = {\n                lat: this.latitude,\n                lng: this.longitude,\n            };\n            if (this.usePanning) {\n                this._mapsWrapper.panTo(newCenter);\n            }\n            else {\n                this._mapsWrapper.setCenter(newCenter);\n            }\n        }\n        _fitBounds() {\n            switch (this.fitBounds) {\n                case true:\n                    this._subscribeToFitBoundsUpdates();\n                    break;\n                case false:\n                    if (this._fitBoundsSubscription) {\n                        this._fitBoundsSubscription.unsubscribe();\n                    }\n                    break;\n                default:\n                    if (this._fitBoundsSubscription) {\n                        this._fitBoundsSubscription.unsubscribe();\n                    }\n                    this._updateBounds(this.fitBounds, this.fitBoundsPadding);\n            }\n        }\n        _subscribeToFitBoundsUpdates() {\n            this._zone.runOutsideAngular(() => {\n                this._fitBoundsSubscription = this._fitBoundsService.getBounds$().subscribe(b => {\n                    this._zone.run(() => this._updateBounds(b, this.fitBoundsPadding));\n                });\n            });\n        }\n        _updateBounds(bounds, padding) {\n            if (!bounds) {\n                return;\n            }\n            if (this._isLatLngBoundsLiteral(bounds) && typeof google !== 'undefined' && google && google.maps && google.maps.LatLngBounds) {\n                const newBounds = new google.maps.LatLngBounds();\n                newBounds.union(bounds);\n                bounds = newBounds;\n            }\n            if (this.usePanning) {\n                this._mapsWrapper.panToBounds(bounds, padding);\n                return;\n            }\n            this._mapsWrapper.fitBounds(bounds, padding);\n        }\n        _isLatLngBoundsLiteral(bounds) {\n            return bounds != null && bounds.extend === undefined;\n        }\n        _handleMapCenterChange() {\n            const s = this._mapsWrapper.subscribeToMapEvent('center_changed').subscribe(() => {\n                this._mapsWrapper.getCenter().then((center) => {\n                    this.latitude = center.lat();\n                    this.longitude = center.lng();\n                    this.centerChange.emit({ lat: this.latitude, lng: this.longitude });\n                });\n            });\n            this._observableSubscriptions.push(s);\n        }\n        _handleBoundsChange() {\n            const s = this._mapsWrapper.subscribeToMapEvent('bounds_changed').subscribe(() => {\n                this._mapsWrapper.getBounds().then((bounds) => { this.boundsChange.emit(bounds); });\n            });\n            this._observableSubscriptions.push(s);\n        }\n        _handleMapTypeIdChange() {\n            const s = this._mapsWrapper.subscribeToMapEvent('maptypeid_changed').subscribe(() => {\n                this._mapsWrapper.getMapTypeId().then((mapTypeId) => { this.mapTypeIdChange.emit(mapTypeId); });\n            });\n            this._observableSubscriptions.push(s);\n        }\n        _handleMapZoomChange() {\n            const s = this._mapsWrapper.subscribeToMapEvent('zoom_changed').subscribe(() => {\n                this._mapsWrapper.getZoom().then((z) => {\n                    this.zoom = z;\n                    this.zoomChange.emit(z);\n                });\n            });\n            this._observableSubscriptions.push(s);\n        }\n        _handleIdleEvent() {\n            const s = this._mapsWrapper.subscribeToMapEvent('idle').subscribe(() => { this.idle.emit(void 0); });\n            this._observableSubscriptions.push(s);\n        }\n        _handleTilesLoadedEvent() {\n            const s = this._mapsWrapper.subscribeToMapEvent('tilesloaded').subscribe(() => this.tilesLoaded.emit(void 0));\n            this._observableSubscriptions.push(s);\n        }\n        _handleMapMouseEvents() {\n            const events = [\n                { name: 'click', emitter: this.mapClick },\n                { name: 'rightclick', emitter: this.mapRightClick },\n                { name: 'dblclick', emitter: this.mapDblClick },\n            ];\n            events.forEach(e => {\n                const s = this._mapsWrapper.subscribeToMapEvent(e.name).subscribe(([event]) => {\n                    // the placeId will be undefined in case the event was not an IconMouseEvent (google types)\n                    if (event.placeId && !this.showDefaultInfoWindow) {\n                        event.stop();\n                    }\n                    e.emitter.emit(event);\n                });\n                this._observableSubscriptions.push(s);\n            });\n        }\n        _handleControlChange() {\n            this._setControls();\n            this.mapControls.changes.subscribe(() => this._setControls());\n        }\n        _setControls() {\n            const controlOptions = {\n                fullscreenControl: !this.disableDefaultUI,\n                mapTypeControl: false,\n                panControl: false,\n                rotateControl: false,\n                scaleControl: false,\n                streetViewControl: !this.disableDefaultUI,\n                zoomControl: !this.disableDefaultUI,\n            };\n            this._mapsWrapper.getNativeMap().then(() => {\n                this.mapControls.forEach(control => Object.assign(controlOptions, control.getOptions()));\n                this._mapsWrapper.setMapOptions(controlOptions);\n            });\n        }\n    }\n    AgmMap.ɵfac = function AgmMap_Factory(t) { return new (t || AgmMap)(core[\"ɵɵdirectiveInject\"](core[\"ElementRef\"]), core[\"ɵɵdirectiveInject\"](agm_core_GoogleMapsAPIWrapper), core[\"ɵɵdirectiveInject\"](core[\"PLATFORM_ID\"]), core[\"ɵɵdirectiveInject\"](agm_core_FitBoundsService), core[\"ɵɵdirectiveInject\"](core[\"NgZone\"])); };\n    AgmMap.ɵcmp = core[\"ɵɵdefineComponent\"]({ type: AgmMap, selectors: [[\"agm-map\"]], contentQueries: function AgmMap_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"ɵɵcontentQuery\"](dirIndex, agm_core_AgmMapControl, 0);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"ɵɵqueryRefresh\"](_t = core[\"ɵɵloadQuery\"]()) && (ctx.mapControls = _t);\n            }\n        }, inputs: { longitude: \"longitude\", latitude: \"latitude\", zoom: \"zoom\", draggable: [\"mapDraggable\", \"draggable\"], disableDoubleClickZoom: \"disableDoubleClickZoom\", disableDefaultUI: \"disableDefaultUI\", scrollwheel: \"scrollwheel\", keyboardShortcuts: \"keyboardShortcuts\", styles: \"styles\", usePanning: \"usePanning\", fitBounds: \"fitBounds\", mapTypeId: \"mapTypeId\", clickableIcons: \"clickableIcons\", showDefaultInfoWindow: \"showDefaultInfoWindow\", gestureHandling: \"gestureHandling\", tilt: \"tilt\", minZoom: \"minZoom\", maxZoom: \"maxZoom\", controlSize: \"controlSize\", backgroundColor: \"backgroundColor\", draggableCursor: \"draggableCursor\", draggingCursor: \"draggingCursor\", fitBoundsPadding: \"fitBoundsPadding\", restriction: \"restriction\" }, outputs: { mapClick: \"mapClick\", mapRightClick: \"mapRightClick\", mapDblClick: \"mapDblClick\", centerChange: \"centerChange\", boundsChange: \"boundsChange\", mapTypeIdChange: \"mapTypeIdChange\", idle: \"idle\", zoomChange: \"zoomChange\", mapReady: \"mapReady\", tilesLoaded: \"tilesLoaded\" }, features: [core[\"ɵɵProvidersFeature\"]([\n                agm_core_CircleManager,\n                agm_core_DataLayerManager,\n                agm_core_DataLayerManager,\n                agm_core_FitBoundsService,\n                agm_core_GoogleMapsAPIWrapper,\n                agm_core_InfoWindowManager,\n                agm_core_KmlLayerManager,\n                agm_core_LayerManager,\n                agm_core_MarkerManager,\n                agm_core_PolygonManager,\n                agm_core_PolylineManager,\n                agm_core_RectangleManager,\n            ]), core[\"ɵɵNgOnChangesFeature\"]], ngContentSelectors: _c0, decls: 3, vars: 0, consts: [[1, \"agm-map-container-inner\", \"sebm-google-map-container-inner\"], [1, \"agm-map-content\"]], template: function AgmMap_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"ɵɵprojectionDef\"]();\n                core[\"ɵɵelement\"](0, \"div\", 0);\n                core[\"ɵɵelementStart\"](1, \"div\", 1);\n                core[\"ɵɵprojection\"](2);\n                core[\"ɵɵelementEnd\"]();\n            }\n        }, styles: [\".agm-map-container-inner[_ngcontent-%COMP%] {\\n      width: inherit;\\n      height: inherit;\\n    }\\n    .agm-map-content[_ngcontent-%COMP%] {\\n      display:none;\\n    }\"] });\n    /**\n     * Map option attributes that can change over time\n     */\n    AgmMap._mapOptionsAttributes = [\n        'disableDoubleClickZoom', 'scrollwheel', 'draggable', 'draggableCursor', 'draggingCursor',\n        'keyboardShortcuts', 'styles', 'zoom', 'minZoom', 'maxZoom', 'mapTypeId', 'clickableIcons',\n        'gestureHandling', 'tilt', 'restriction',\n    ];\n    return AgmMap;\n})();\nlet markerId = 0;\nlet agm_core_AgmMarker = /*@__PURE__*/ (() => {\n    class AgmMarker {\n        constructor(_markerManager) {\n            this._markerManager = _markerManager;\n            /**\n             * If true, the marker can be dragged. Default value is false.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = false;\n            /**\n             * If true, the marker is visible\n             */\n            this.visible = true;\n            /**\n             * Whether to automatically open the child info window when the marker is clicked.\n             */\n            this.openInfoWindow = true;\n            /**\n             * The marker's opacity between 0.0 and 1.0.\n             */\n            this.opacity = 1;\n            /**\n             * All markers are displayed on the map in order of their zIndex, with higher values displaying in\n             * front of markers with lower values. By default, markers are displayed according to their\n             * vertical position on screen, with lower markers appearing in front of markers further up the\n             * screen.\n             */\n            this.zIndex = 1;\n            /**\n             * If true, the marker can be clicked. Default value is true.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.clickable = true;\n            /**\n             * This event is fired when the marker's animation property changes.\n             */\n            this.animationChange = new core[\"EventEmitter\"]();\n            /**\n             * This event emitter gets emitted when the user clicks on the marker.\n             */\n            this.markerClick = new core[\"EventEmitter\"]();\n            /**\n             * This event emitter gets emitted when the user clicks twice on the marker.\n             */\n            this.markerDblClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user rightclicks on the marker.\n             */\n            this.markerRightClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user starts dragging the marker.\n             */\n            this.dragStart = new core[\"EventEmitter\"]();\n            /**\n             * This event is repeatedly fired while the user drags the marker.\n             */\n            // tslint:disable-next-line: no-output-native\n            this.drag = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user stops dragging the marker.\n             */\n            this.dragEnd = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user mouses over the marker.\n             */\n            this.mouseOver = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user mouses outside the marker.\n             */\n            this.mouseOut = new core[\"EventEmitter\"]();\n            /** @internal */\n            this.infoWindow = new core[\"QueryList\"]();\n            this._markerAddedToManger = false;\n            this._observableSubscriptions = [];\n            this._fitBoundsDetails$ = new ReplaySubject_ReplaySubject(1);\n            this._id = (markerId++).toString();\n        }\n        /* @internal */\n        ngAfterContentInit() {\n            this.handleInfoWindowUpdate();\n            this.infoWindow.changes.subscribe(() => this.handleInfoWindowUpdate());\n        }\n        handleInfoWindowUpdate() {\n            if (this.infoWindow.length > 1) {\n                throw new Error('Expected no more than one info window.');\n            }\n            this.infoWindow.forEach(marker => {\n                marker.hostMarker = this;\n            });\n        }\n        /** @internal */\n        ngOnChanges(changes) {\n            if (typeof this.latitude === 'string') {\n                this.latitude = Number(this.latitude);\n            }\n            if (typeof this.longitude === 'string') {\n                this.longitude = Number(this.longitude);\n            }\n            if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {\n                return;\n            }\n            if (!this._markerAddedToManger) {\n                this._markerManager.addMarker(this);\n                this._updateFitBoundsDetails();\n                this._markerAddedToManger = true;\n                this._addEventListeners();\n                return;\n            }\n            // tslint:disable: no-string-literal\n            if (changes['latitude'] || changes['longitude']) {\n                this._markerManager.updateMarkerPosition(this);\n                this._updateFitBoundsDetails();\n            }\n            if (changes['title']) {\n                this._markerManager.updateTitle(this);\n            }\n            if (changes['label']) {\n                this._markerManager.updateLabel(this);\n            }\n            if (changes['draggable']) {\n                this._markerManager.updateDraggable(this);\n            }\n            if (changes['iconUrl']) {\n                this._markerManager.updateIcon(this);\n            }\n            if (changes['opacity']) {\n                this._markerManager.updateOpacity(this);\n            }\n            if (changes['visible']) {\n                this._markerManager.updateVisible(this);\n            }\n            if (changes['zIndex']) {\n                this._markerManager.updateZIndex(this);\n            }\n            if (changes['clickable']) {\n                this._markerManager.updateClickable(this);\n            }\n            if (changes['animation']) {\n                this._markerManager.updateAnimation(this);\n            }\n            // tslint:enable: no-string-literal\n        }\n        /** @internal */\n        getFitBoundsDetails$() {\n            return this._fitBoundsDetails$.asObservable();\n        }\n        _updateFitBoundsDetails() {\n            this._fitBoundsDetails$.next({ latLng: { lat: this.latitude, lng: this.longitude } });\n        }\n        _addEventListeners() {\n            const cs = this._markerManager.createEventObservable('click', this).subscribe(() => {\n                if (this.openInfoWindow) {\n                    this.infoWindow.forEach(infoWindow => infoWindow.open());\n                }\n                this.markerClick.emit(this);\n            });\n            this._observableSubscriptions.push(cs);\n            const dcs = this._markerManager.createEventObservable('dblclick', this).subscribe(() => {\n                this.markerDblClick.emit(null);\n            });\n            this._observableSubscriptions.push(dcs);\n            const rc = this._markerManager.createEventObservable('rightclick', this).subscribe(() => {\n                this.markerRightClick.emit(null);\n            });\n            this._observableSubscriptions.push(rc);\n            const ds = this._markerManager.createEventObservable('dragstart', this)\n                .subscribe(e => this.dragStart.emit(e));\n            this._observableSubscriptions.push(ds);\n            const d = this._markerManager.createEventObservable('drag', this)\n                .subscribe(e => this.drag.emit(e));\n            this._observableSubscriptions.push(d);\n            const de = this._markerManager.createEventObservable('dragend', this)\n                .subscribe(e => this.dragEnd.emit(e));\n            this._observableSubscriptions.push(de);\n            const mover = this._markerManager.createEventObservable('mouseover', this)\n                .subscribe(e => this.mouseOver.emit(e));\n            this._observableSubscriptions.push(mover);\n            const mout = this._markerManager.createEventObservable('mouseout', this)\n                .subscribe(e => this.mouseOut.emit(e));\n            this._observableSubscriptions.push(mout);\n            const anChng = this._markerManager.createEventObservable('animation_changed', this)\n                .subscribe(() => {\n                this.animationChange.emit(this.animation);\n            });\n            this._observableSubscriptions.push(anChng);\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return 'AgmMarker-' + this._id.toString(); }\n        /** @internal */\n        ngOnDestroy() {\n            this._markerManager.deleteMarker(this);\n            // unsubscribe all registered observable subscriptions\n            this._observableSubscriptions.forEach((s) => s.unsubscribe());\n        }\n    }\n    AgmMarker.ɵfac = function AgmMarker_Factory(t) { return new (t || AgmMarker)(core[\"ɵɵdirectiveInject\"](agm_core_MarkerManager)); };\n    AgmMarker.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmMarker, selectors: [[\"agm-marker\"]], contentQueries: function AgmMarker_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"ɵɵcontentQuery\"](dirIndex, agm_core_AgmInfoWindow, 0);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"ɵɵqueryRefresh\"](_t = core[\"ɵɵloadQuery\"]()) && (ctx.infoWindow = _t);\n            }\n        }, inputs: { draggable: [\"markerDraggable\", \"draggable\"], visible: \"visible\", openInfoWindow: \"openInfoWindow\", opacity: \"opacity\", zIndex: \"zIndex\", clickable: [\"markerClickable\", \"clickable\"], latitude: \"latitude\", longitude: \"longitude\", title: \"title\", label: \"label\", iconUrl: \"iconUrl\", animation: \"animation\" }, outputs: { animationChange: \"animationChange\", markerClick: \"markerClick\", markerDblClick: \"markerDblClick\", markerRightClick: \"markerRightClick\", dragStart: \"dragStart\", drag: \"drag\", dragEnd: \"dragEnd\", mouseOver: \"mouseOver\", mouseOut: \"mouseOut\" }, features: [core[\"ɵɵProvidersFeature\"]([\n                { provide: FitBoundsAccessor, useExisting: Object(core[\"forwardRef\"])(() => AgmMarker) },\n            ]), core[\"ɵɵNgOnChangesFeature\"]] });\n    return AgmMarker;\n})();\nlet agm_core_AgmPolygon = /*@__PURE__*/ (() => {\n    class AgmPolygon {\n        constructor(_polygonManager) {\n            this._polygonManager = _polygonManager;\n            /**\n             * Indicates whether this Polygon handles mouse events. Defaults to true.\n             */\n            this.clickable = true;\n            /**\n             * If set to true, the user can drag this shape over the map. The geodesic\n             * property defines the mode of dragging. Defaults to false.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = false;\n            /**\n             * If set to true, the user can edit this shape by dragging the control\n             * points shown at the vertices and on each segment. Defaults to false.\n             */\n            this.editable = false;\n            /**\n             * When true, edges of the polygon are interpreted as geodesic and will\n             * follow the curvature of the Earth. When false, edges of the polygon are\n             * rendered as straight lines in screen space. Note that the shape of a\n             * geodesic polygon may appear to change when dragged, as the dimensions\n             * are maintained relative to the surface of the earth. Defaults to false.\n             */\n            this.geodesic = false;\n            /**\n             * The ordered sequence of coordinates that designates a closed loop.\n             * Unlike polylines, a polygon may consist of one or more paths.\n             *  As a result, the paths property may specify one or more arrays of\n             * LatLng coordinates. Paths are closed automatically; do not repeat the\n             * first vertex of the path as the last vertex. Simple polygons may be\n             * defined using a single array of LatLngs. More complex polygons may\n             * specify an array of arrays. Any simple arrays are converted into Arrays.\n             * Inserting or removing LatLngs from the Array will automatically update\n             * the polygon on the map.\n             */\n            this.paths = [];\n            /**\n             * This event is fired when the DOM click event is fired on the Polygon.\n             */\n            this.polyClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM dblclick event is fired on the Polygon.\n             */\n            this.polyDblClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is repeatedly fired while the user drags the polygon.\n             */\n            this.polyDrag = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user stops dragging the polygon.\n             */\n            this.polyDragEnd = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user starts dragging the polygon.\n             */\n            this.polyDragStart = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM mousedown event is fired on the Polygon.\n             */\n            this.polyMouseDown = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM mousemove event is fired on the Polygon.\n             */\n            this.polyMouseMove = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired on Polygon mouseout.\n             */\n            this.polyMouseOut = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired on Polygon mouseover.\n             */\n            this.polyMouseOver = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired whe the DOM mouseup event is fired on the Polygon\n             */\n            this.polyMouseUp = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the Polygon is right-clicked on.\n             */\n            this.polyRightClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired after Polygon first path changes.\n             */\n            this.polyPathsChange = new core[\"EventEmitter\"]();\n            this._polygonAddedToManager = false;\n            this._subscriptions = [];\n        }\n        /** @internal */\n        ngAfterContentInit() {\n            if (!this._polygonAddedToManager) {\n                this._init();\n            }\n        }\n        ngOnChanges(changes) {\n            if (!this._polygonAddedToManager) {\n                this._init();\n                return;\n            }\n            this._polygonManager.setPolygonOptions(this, this._updatePolygonOptions(changes));\n        }\n        _init() {\n            this._polygonManager.addPolygon(this);\n            this._polygonAddedToManager = true;\n            this._addEventListeners();\n        }\n        _addEventListeners() {\n            const handlers = [\n                { name: 'click', handler: (ev) => this.polyClick.emit(ev) },\n                { name: 'dblclick', handler: (ev) => this.polyDblClick.emit(ev) },\n                { name: 'drag', handler: (ev) => this.polyDrag.emit(ev) },\n                { name: 'dragend', handler: (ev) => this.polyDragEnd.emit(ev) },\n                { name: 'dragstart', handler: (ev) => this.polyDragStart.emit(ev) },\n                { name: 'mousedown', handler: (ev) => this.polyMouseDown.emit(ev) },\n                { name: 'mousemove', handler: (ev) => this.polyMouseMove.emit(ev) },\n                { name: 'mouseout', handler: (ev) => this.polyMouseOut.emit(ev) },\n                { name: 'mouseover', handler: (ev) => this.polyMouseOver.emit(ev) },\n                { name: 'mouseup', handler: (ev) => this.polyMouseUp.emit(ev) },\n                { name: 'rightclick', handler: (ev) => this.polyRightClick.emit(ev) },\n            ];\n            handlers.forEach((obj) => {\n                const os = this._polygonManager.createEventObservable(obj.name, this).subscribe(obj.handler);\n                this._subscriptions.push(os);\n            });\n            this._polygonManager.createPathEventObservable(this)\n                .then(paths$ => {\n                const os = paths$.subscribe(pathEvent => this.polyPathsChange.emit(pathEvent));\n                this._subscriptions.push(os);\n            });\n        }\n        _updatePolygonOptions(changes) {\n            return Object.keys(changes)\n                .filter(k => AgmPolygon._polygonOptionsAttributes.indexOf(k) !== -1)\n                .reduce((obj, k) => {\n                obj[k] = changes[k].currentValue;\n                return obj;\n            }, {});\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        ngOnDestroy() {\n            this._polygonManager.deletePolygon(this);\n            // unsubscribe all registered observable subscriptions\n            this._subscriptions.forEach((s) => s.unsubscribe());\n        }\n        getPath() {\n            return this._polygonManager.getPath(this);\n        }\n        getPaths() {\n            return this._polygonManager.getPaths(this);\n        }\n    }\n    AgmPolygon.ɵfac = function AgmPolygon_Factory(t) { return new (t || AgmPolygon)(core[\"ɵɵdirectiveInject\"](agm_core_PolygonManager)); };\n    AgmPolygon.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmPolygon, selectors: [[\"agm-polygon\"]], inputs: { clickable: \"clickable\", draggable: [\"polyDraggable\", \"draggable\"], editable: \"editable\", geodesic: \"geodesic\", paths: \"paths\", fillColor: \"fillColor\", fillOpacity: \"fillOpacity\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", strokeWeight: \"strokeWeight\", visible: \"visible\", zIndex: \"zIndex\" }, outputs: { polyClick: \"polyClick\", polyDblClick: \"polyDblClick\", polyDrag: \"polyDrag\", polyDragEnd: \"polyDragEnd\", polyDragStart: \"polyDragStart\", polyMouseDown: \"polyMouseDown\", polyMouseMove: \"polyMouseMove\", polyMouseOut: \"polyMouseOut\", polyMouseOver: \"polyMouseOver\", polyMouseUp: \"polyMouseUp\", polyRightClick: \"polyRightClick\", polyPathsChange: \"polyPathsChange\" }, features: [core[\"ɵɵNgOnChangesFeature\"]] });\n    AgmPolygon._polygonOptionsAttributes = [\n        'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'icon', 'map',\n        'paths', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'draggable',\n        'editable', 'visible',\n    ];\n    return AgmPolygon;\n})();\nlet agm_core_AgmPolylineIcon = /*@__PURE__*/ (() => {\n    class AgmPolylineIcon {\n        ngOnInit() {\n            if (this.path == null) {\n                throw new Error('Icon Sequence path is required');\n            }\n        }\n    }\n    AgmPolylineIcon.ɵfac = function AgmPolylineIcon_Factory(t) { return new (t || AgmPolylineIcon)(); };\n    AgmPolylineIcon.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmPolylineIcon, selectors: [[\"agm-icon-sequence\"]], inputs: { fixedRotation: \"fixedRotation\", offset: \"offset\", repeat: \"repeat\", anchorX: \"anchorX\", anchorY: \"anchorY\", fillColor: \"fillColor\", fillOpacity: \"fillOpacity\", path: \"path\", rotation: \"rotation\", scale: \"scale\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", strokeWeight: \"strokeWeight\" } });\n    return AgmPolylineIcon;\n})();\nlet agm_core_AgmPolylinePoint = /*@__PURE__*/ (() => {\n    class AgmPolylinePoint {\n        constructor() {\n            /**\n             * This event emitter gets emitted when the position of the point changed.\n             */\n            this.positionChanged = new core[\"EventEmitter\"]();\n        }\n        ngOnChanges(changes) {\n            // tslint:disable: no-string-literal\n            if (changes['latitude'] || changes['longitude']) {\n                this.positionChanged.emit({\n                    lat: changes['latitude'] ? changes['latitude'].currentValue : this.latitude,\n                    lng: changes['longitude'] ? changes['longitude'].currentValue : this.longitude,\n                });\n            }\n            // tslint:enable: no-string-literal\n        }\n        /** @internal */\n        getFitBoundsDetails$() {\n            return this.positionChanged.pipe(Object(startWith[\"a\" /* startWith */])({ lat: this.latitude, lng: this.longitude }), Object(map[\"a\" /* map */])(position => ({ latLng: position })));\n        }\n    }\n    AgmPolylinePoint.ɵfac = function AgmPolylinePoint_Factory(t) { return new (t || AgmPolylinePoint)(); };\n    AgmPolylinePoint.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmPolylinePoint, selectors: [[\"agm-polyline-point\"]], inputs: { latitude: \"latitude\", longitude: \"longitude\" }, outputs: { positionChanged: \"positionChanged\" }, features: [core[\"ɵɵProvidersFeature\"]([\n                { provide: FitBoundsAccessor, useExisting: Object(core[\"forwardRef\"])(() => AgmPolylinePoint) },\n            ]), core[\"ɵɵNgOnChangesFeature\"]] });\n    return AgmPolylinePoint;\n})();\nlet polylineId = 0;\nlet agm_core_AgmPolyline = /*@__PURE__*/ (() => {\n    class AgmPolyline {\n        constructor(_polylineManager) {\n            this._polylineManager = _polylineManager;\n            /**\n             * Indicates whether this Polyline handles mouse events. Defaults to true.\n             */\n            this.clickable = true;\n            /**\n             * If set to true, the user can drag this shape over the map. The geodesic property defines the\n             * mode of dragging. Defaults to false.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = false;\n            /**\n             * If set to true, the user can edit this shape by dragging the control points shown at the\n             * vertices and on each segment. Defaults to false.\n             */\n            this.editable = false;\n            /**\n             * When true, edges of the polygon are interpreted as geodesic and will follow the curvature of\n             * the Earth. When false, edges of the polygon are rendered as straight lines in screen space.\n             * Note that the shape of a geodesic polygon may appear to change when dragged, as the dimensions\n             * are maintained relative to the surface of the earth. Defaults to false.\n             */\n            this.geodesic = false;\n            /**\n             * Whether this polyline is visible on the map. Defaults to true.\n             */\n            this.visible = true;\n            /**\n             * This event is fired when the DOM click event is fired on the Polyline.\n             */\n            this.lineClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM dblclick event is fired on the Polyline.\n             */\n            this.lineDblClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is repeatedly fired while the user drags the polyline.\n             */\n            this.lineDrag = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user stops dragging the polyline.\n             */\n            this.lineDragEnd = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user starts dragging the polyline.\n             */\n            this.lineDragStart = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM mousedown event is fired on the Polyline.\n             */\n            this.lineMouseDown = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM mousemove event is fired on the Polyline.\n             */\n            this.lineMouseMove = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired on Polyline mouseout.\n             */\n            this.lineMouseOut = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired on Polyline mouseover.\n             */\n            this.lineMouseOver = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired whe the DOM mouseup event is fired on the Polyline\n             */\n            this.lineMouseUp = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the Polyline is right-clicked on.\n             */\n            this.lineRightClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired after Polyline's path changes.\n             */\n            this.polyPathChange = new core[\"EventEmitter\"]();\n            this._polylineAddedToManager = false;\n            this._subscriptions = [];\n            this._id = (polylineId++).toString();\n        }\n        /** @internal */\n        ngAfterContentInit() {\n            if (this.points.length) {\n                this.points.forEach((point) => {\n                    const s = point.positionChanged.subscribe(() => { this._polylineManager.updatePolylinePoints(this); });\n                    this._subscriptions.push(s);\n                });\n            }\n            if (!this._polylineAddedToManager) {\n                this._init();\n            }\n            const pointSub = this.points.changes.subscribe(() => this._polylineManager.updatePolylinePoints(this));\n            this._subscriptions.push(pointSub);\n            this._polylineManager.updatePolylinePoints(this);\n            const iconSub = this.iconSequences.changes.subscribe(() => this._polylineManager.updateIconSequences(this));\n            this._subscriptions.push(iconSub);\n        }\n        ngOnChanges(changes) {\n            if (!this._polylineAddedToManager) {\n                this._init();\n                return;\n            }\n            const options = {};\n            const optionKeys = Object.keys(changes).filter(k => AgmPolyline._polylineOptionsAttributes.indexOf(k) !== -1);\n            optionKeys.forEach(k => options[k] = changes[k].currentValue);\n            this._polylineManager.setPolylineOptions(this, options);\n        }\n        getPath() {\n            return this._polylineManager.getPath(this);\n        }\n        _init() {\n            this._polylineManager.addPolyline(this);\n            this._polylineAddedToManager = true;\n            this._addEventListeners();\n        }\n        _addEventListeners() {\n            const handlers = [\n                { name: 'click', handler: (ev) => this.lineClick.emit(ev) },\n                { name: 'dblclick', handler: (ev) => this.lineDblClick.emit(ev) },\n                { name: 'drag', handler: (ev) => this.lineDrag.emit(ev) },\n                { name: 'dragend', handler: (ev) => this.lineDragEnd.emit(ev) },\n                { name: 'dragstart', handler: (ev) => this.lineDragStart.emit(ev) },\n                { name: 'mousedown', handler: (ev) => this.lineMouseDown.emit(ev) },\n                { name: 'mousemove', handler: (ev) => this.lineMouseMove.emit(ev) },\n                { name: 'mouseout', handler: (ev) => this.lineMouseOut.emit(ev) },\n                { name: 'mouseover', handler: (ev) => this.lineMouseOver.emit(ev) },\n                { name: 'mouseup', handler: (ev) => this.lineMouseUp.emit(ev) },\n                { name: 'rightclick', handler: (ev) => this.lineRightClick.emit(ev) },\n            ];\n            handlers.forEach((obj) => {\n                const os = this._polylineManager.createEventObservable(obj.name, this).subscribe(obj.handler);\n                this._subscriptions.push(os);\n            });\n            this._polylineManager.createPathEventObservable(this).then((ob$) => {\n                const os = ob$.subscribe(pathEvent => this.polyPathChange.emit(pathEvent));\n                this._subscriptions.push(os);\n            });\n        }\n        /** @internal */\n        _getPoints() {\n            if (this.points) {\n                return this.points.toArray();\n            }\n            return [];\n        }\n        _getIcons() {\n            if (this.iconSequences) {\n                return this.iconSequences.toArray();\n            }\n            return [];\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        ngOnDestroy() {\n            this._polylineManager.deletePolyline(this);\n            // unsubscribe all registered observable subscriptions\n            this._subscriptions.forEach((s) => s.unsubscribe());\n        }\n    }\n    AgmPolyline.ɵfac = function AgmPolyline_Factory(t) { return new (t || AgmPolyline)(core[\"ɵɵdirectiveInject\"](agm_core_PolylineManager)); };\n    AgmPolyline.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmPolyline, selectors: [[\"agm-polyline\"]], contentQueries: function AgmPolyline_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"ɵɵcontentQuery\"](dirIndex, agm_core_AgmPolylinePoint, 0);\n                core[\"ɵɵcontentQuery\"](dirIndex, agm_core_AgmPolylineIcon, 0);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"ɵɵqueryRefresh\"](_t = core[\"ɵɵloadQuery\"]()) && (ctx.points = _t);\n                core[\"ɵɵqueryRefresh\"](_t = core[\"ɵɵloadQuery\"]()) && (ctx.iconSequences = _t);\n            }\n        }, inputs: { clickable: \"clickable\", draggable: [\"polylineDraggable\", \"draggable\"], editable: \"editable\", geodesic: \"geodesic\", visible: \"visible\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", strokeWeight: \"strokeWeight\", zIndex: \"zIndex\" }, outputs: { lineClick: \"lineClick\", lineDblClick: \"lineDblClick\", lineDrag: \"lineDrag\", lineDragEnd: \"lineDragEnd\", lineDragStart: \"lineDragStart\", lineMouseDown: \"lineMouseDown\", lineMouseMove: \"lineMouseMove\", lineMouseOut: \"lineMouseOut\", lineMouseOver: \"lineMouseOver\", lineMouseUp: \"lineMouseUp\", lineRightClick: \"lineRightClick\", polyPathChange: \"polyPathChange\" }, features: [core[\"ɵɵNgOnChangesFeature\"]] });\n    AgmPolyline._polylineOptionsAttributes = [\n        'draggable', 'editable', 'visible', 'geodesic', 'strokeColor', 'strokeOpacity', 'strokeWeight',\n        'zIndex',\n    ];\n    return AgmPolyline;\n})();\nlet agm_core_AgmRectangle = /*@__PURE__*/ (() => {\n    class AgmRectangle {\n        constructor(_manager) {\n            this._manager = _manager;\n            /**\n             * Indicates whether this Rectangle handles mouse events. Defaults to true.\n             */\n            this.clickable = true;\n            /**\n             * If set to true, the user can drag this rectangle over the map. Defaults to false.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = false;\n            /**\n             * If set to true, the user can edit this rectangle by dragging the control points shown at\n             * the center and around the circumference of the rectangle. Defaults to false.\n             */\n            this.editable = false;\n            /**\n             * The stroke position. Defaults to CENTER.\n             * This property is not supported on Internet Explorer 8 and earlier.\n             */\n            this.strokePosition = 'CENTER';\n            /**\n             * The stroke width in pixels.\n             */\n            this.strokeWeight = 0;\n            /**\n             * Whether this rectangle is visible on the map. Defaults to true.\n             */\n            this.visible = true;\n            /**\n             * This event is fired when the rectangle's is changed.\n             */\n            this.boundsChange = new core[\"EventEmitter\"]();\n            /**\n             * This event emitter gets emitted when the user clicks on the rectangle.\n             */\n            this.rectangleClick = new core[\"EventEmitter\"]();\n            /**\n             * This event emitter gets emitted when the user clicks on the rectangle.\n             */\n            this.rectangleDblClick = new core[\"EventEmitter\"]();\n            /**\n             * This event is repeatedly fired while the user drags the rectangle.\n             */\n            // tslint:disable-next-line: no-output-native\n            this.drag = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user stops dragging the rectangle.\n             */\n            this.dragEnd = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the user starts dragging the rectangle.\n             */\n            this.dragStart = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM mousedown event is fired on the rectangle.\n             */\n            this.mouseDown = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM mousemove event is fired on the rectangle.\n             */\n            this.mouseMove = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired on rectangle mouseout.\n             */\n            this.mouseOut = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired on rectangle mouseover.\n             */\n            this.mouseOver = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the DOM mouseup event is fired on the rectangle.\n             */\n            this.mouseUp = new core[\"EventEmitter\"]();\n            /**\n             * This event is fired when the rectangle is right-clicked on.\n             */\n            this.rightClick = new core[\"EventEmitter\"]();\n            this._rectangleAddedToManager = false;\n            this._eventSubscriptions = [];\n        }\n        /** @internal */\n        ngOnInit() {\n            this._manager.addRectangle(this);\n            this._rectangleAddedToManager = true;\n            this._registerEventListeners();\n        }\n        /** @internal */\n        ngOnChanges(changes) {\n            if (!this._rectangleAddedToManager) {\n                return;\n            }\n            // tslint:disable: no-string-literal\n            if (changes['north'] ||\n                changes['east'] ||\n                changes['south'] ||\n                changes['west']) {\n                this._manager.setBounds(this);\n            }\n            if (changes['editable']) {\n                this._manager.setEditable(this);\n            }\n            if (changes['draggable']) {\n                this._manager.setDraggable(this);\n            }\n            if (changes['visible']) {\n                this._manager.setVisible(this);\n            }\n            // tslint:enable: no-string-literal\n            this._updateRectangleOptionsChanges(changes);\n        }\n        _updateRectangleOptionsChanges(changes) {\n            const options = {};\n            const optionKeys = Object.keys(changes).filter(k => AgmRectangle._mapOptions.indexOf(k) !== -1);\n            optionKeys.forEach(k => {\n                options[k] = changes[k].currentValue;\n            });\n            if (optionKeys.length > 0) {\n                this._manager.setOptions(this, options);\n            }\n        }\n        _registerEventListeners() {\n            const events = new Map();\n            events.set('bounds_changed', this.boundsChange);\n            events.set('click', this.rectangleClick);\n            events.set('dblclick', this.rectangleDblClick);\n            events.set('drag', this.drag);\n            events.set('dragend', this.dragEnd);\n            events.set('dragStart', this.dragStart);\n            events.set('mousedown', this.mouseDown);\n            events.set('mousemove', this.mouseMove);\n            events.set('mouseout', this.mouseOut);\n            events.set('mouseover', this.mouseOver);\n            events.set('mouseup', this.mouseUp);\n            events.set('rightclick', this.rightClick);\n            events.forEach((eventEmitter, eventName) => {\n                this._eventSubscriptions.push(this._manager\n                    .createEventObservable(eventName, this)\n                    .subscribe(value => {\n                    switch (eventName) {\n                        case 'bounds_changed':\n                            this._manager.getBounds(this).then(bounds => eventEmitter.emit({\n                                north: bounds.getNorthEast().lat(),\n                                east: bounds.getNorthEast().lng(),\n                                south: bounds.getSouthWest().lat(),\n                                west: bounds.getSouthWest().lng(),\n                            }));\n                            break;\n                        default:\n                            eventEmitter.emit(value);\n                    }\n                }));\n            });\n        }\n        /** @internal */\n        ngOnDestroy() {\n            this._eventSubscriptions.forEach(s => s.unsubscribe());\n            this._eventSubscriptions = null;\n            this._manager.removeRectangle(this);\n        }\n        /**\n         * Gets the LatLngBounds of this Rectangle.\n         */\n        getBounds() {\n            return this._manager.getBounds(this);\n        }\n    }\n    AgmRectangle.ɵfac = function AgmRectangle_Factory(t) { return new (t || AgmRectangle)(core[\"ɵɵdirectiveInject\"](agm_core_RectangleManager)); };\n    AgmRectangle.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmRectangle, selectors: [[\"agm-rectangle\"]], inputs: { clickable: \"clickable\", draggable: [\"rectangleDraggable\", \"draggable\"], editable: \"editable\", strokePosition: \"strokePosition\", strokeWeight: \"strokeWeight\", visible: \"visible\", north: \"north\", east: \"east\", south: \"south\", west: \"west\", fillColor: \"fillColor\", fillOpacity: \"fillOpacity\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", zIndex: \"zIndex\" }, outputs: { boundsChange: \"boundsChange\", rectangleClick: \"rectangleClick\", rectangleDblClick: \"rectangleDblClick\", drag: \"drag\", dragEnd: \"dragEnd\", dragStart: \"dragStart\", mouseDown: \"mouseDown\", mouseMove: \"mouseMove\", mouseOut: \"mouseOut\", mouseOver: \"mouseOver\", mouseUp: \"mouseUp\", rightClick: \"rightClick\" }, features: [core[\"ɵɵNgOnChangesFeature\"]] });\n    AgmRectangle._mapOptions = [\n        'fillColor',\n        'fillOpacity',\n        'strokeColor',\n        'strokeOpacity',\n        'strokePosition',\n        'strokeWeight',\n        'visible',\n        'zIndex',\n        'clickable',\n    ];\n    return AgmRectangle;\n})();\nlet layerId$3 = 0;\nlet agm_core_AgmTransitLayer = /*@__PURE__*/ (() => {\n    class AgmTransitLayer {\n        constructor(_manager) {\n            this._manager = _manager;\n            this._addedToManager = false;\n            this._id = (layerId$3++).toString();\n            /**\n             * Hide/show transit layer\n             */\n            this.visible = true;\n        }\n        ngOnInit() {\n            if (this._addedToManager) {\n                return;\n            }\n            this._manager.addTransitLayer(this);\n            this._addedToManager = true;\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return `AgmTransitLayer-${this._id.toString()}`; }\n        /** @internal */\n        ngOnDestroy() {\n            this._manager.deleteLayer(this);\n        }\n    }\n    AgmTransitLayer.ɵfac = function AgmTransitLayer_Factory(t) { return new (t || AgmTransitLayer)(core[\"ɵɵdirectiveInject\"](agm_core_LayerManager)); };\n    AgmTransitLayer.ɵdir = core[\"ɵɵdefineDirective\"]({ type: AgmTransitLayer, selectors: [[\"agm-transit-layer\"]], inputs: { visible: \"visible\" } });\n    return AgmTransitLayer;\n})();\n/**\n * @internal\n */\nfunction coreDirectives() {\n    return [\n        agm_core_AgmBicyclingLayer,\n        agm_core_AgmCircle,\n        agm_core_AgmDataLayer,\n        agm_core_AgmFitBounds,\n        agm_core_AgmFullscreenControl,\n        agm_core_AgmInfoWindow,\n        agm_core_AgmKmlLayer,\n        agm_core_AgmMap,\n        agm_core_AgmMapTypeControl,\n        agm_core_AgmMarker,\n        agm_core_AgmPanControl,\n        agm_core_AgmPolygon,\n        agm_core_AgmPolyline,\n        agm_core_AgmPolylineIcon,\n        agm_core_AgmPolylinePoint,\n        agm_core_AgmRectangle,\n        agm_core_AgmRotateControl,\n        agm_core_AgmScaleControl,\n        agm_core_AgmStreetViewControl,\n        agm_core_AgmTransitLayer,\n        agm_core_AgmZoomControl,\n    ];\n}\nlet agm_core_AgmCoreModule = /*@__PURE__*/ (() => {\n    class AgmCoreModule {\n        /**\n         * Please use this method when you register the module at the root level.\n         */\n        static forRoot(lazyMapsAPILoaderConfig) {\n            return {\n                ngModule: AgmCoreModule,\n                providers: [\n                    ...BROWSER_GLOBALS_PROVIDERS, { provide: agm_core_MapsAPILoader, useClass: agm_core_LazyMapsAPILoader },\n                    { provide: LAZY_MAPS_API_CONFIG, useValue: lazyMapsAPILoaderConfig },\n                ],\n            };\n        }\n    }\n    AgmCoreModule.ɵfac = function AgmCoreModule_Factory(t) { return new (t || AgmCoreModule)(); };\n    AgmCoreModule.ɵmod = core[\"ɵɵdefineNgModule\"]({ type: AgmCoreModule });\n    AgmCoreModule.ɵinj = core[\"ɵɵdefineInjector\"]({});\n    return AgmCoreModule;\n})();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"ɵɵsetNgModuleScope\"](agm_core_AgmCoreModule, { declarations: [agm_core_AgmBicyclingLayer, agm_core_AgmCircle, agm_core_AgmDataLayer, agm_core_AgmFitBounds, agm_core_AgmFullscreenControl, agm_core_AgmInfoWindow, agm_core_AgmKmlLayer, agm_core_AgmMap, agm_core_AgmMapTypeControl, agm_core_AgmMarker, agm_core_AgmPanControl, agm_core_AgmPolygon, agm_core_AgmPolyline, agm_core_AgmPolylineIcon, agm_core_AgmPolylinePoint, agm_core_AgmRectangle, agm_core_AgmRotateControl, agm_core_AgmScaleControl, agm_core_AgmStreetViewControl, agm_core_AgmTransitLayer, agm_core_AgmZoomControl], exports: [agm_core_AgmBicyclingLayer, agm_core_AgmCircle, agm_core_AgmDataLayer, agm_core_AgmFitBounds, agm_core_AgmFullscreenControl, agm_core_AgmInfoWindow, agm_core_AgmKmlLayer, agm_core_AgmMap, agm_core_AgmMapTypeControl, agm_core_AgmMarker, agm_core_AgmPanControl, agm_core_AgmPolygon, agm_core_AgmPolyline, agm_core_AgmPolylineIcon, agm_core_AgmPolylinePoint, agm_core_AgmRectangle, agm_core_AgmRotateControl, agm_core_AgmScaleControl, agm_core_AgmStreetViewControl, agm_core_AgmTransitLayer, agm_core_AgmZoomControl] }); })();\n/*\n * Public API Surface of core\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=agm-core.js.map\n\n\n/***/ })\n\n}]);","inputSourceMap":null}