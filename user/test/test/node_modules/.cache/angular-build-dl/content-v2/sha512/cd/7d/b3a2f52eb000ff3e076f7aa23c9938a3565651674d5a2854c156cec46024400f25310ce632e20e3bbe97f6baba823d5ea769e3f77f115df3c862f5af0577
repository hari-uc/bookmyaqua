{"version":3,"sources":["./node_modules/agm-direction/__ivy_ngcc__/fesm2015/agm-direction.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEiF;AAChC;;AAET;AACJ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAY;AACxC;AACA,8BAA8B,0DAAY;AAC1C;AACA,kCAAkC,0DAAY;AAC9C;AACA,0BAA0B,0DAAY;AACtC;AACA,8BAA8B,0DAAY;AAC1C,mCAAmC,0DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AA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","file":"default~pages-cart-cart-module~pages-home-home-module~pages-track-track-module-es2015.js","sourcesContent":["/**\n * @license agm-direction\n * MIT license\n */\n\nimport { EventEmitter, Directive, Input, Output, NgModule } from '@angular/core';\nimport { GoogleMapsAPIWrapper } from '@agm/core';\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@agm/core';\nclass AgmDirection {\r\n    constructor(gmapsApi) {\r\n        this.gmapsApi = gmapsApi;\r\n        this.waypoints = [];\r\n        this.optimizeWaypoints = true;\r\n        this.provideRouteAlternatives = false;\r\n        this.avoidHighways = false;\r\n        this.avoidTolls = false;\r\n        this.avoidFerries = false;\r\n        // Remove or draw direction\r\n        this.visible = true;\r\n        // Direction change event handler\r\n        this.onChange = new EventEmitter();\r\n        // Direction response for the new request\r\n        this.onResponse = new EventEmitter();\r\n        // Send a custom infowindow\r\n        this.sendInfoWindow = new EventEmitter();\r\n        // Status of Directions Query (google.maps.DirectionsStatus.OVER_QUERY_LIMIT)\r\n        this.status = new EventEmitter();\r\n        // Marker drag event handler\r\n        this.originDrag = new EventEmitter();\r\n        this.destinationDrag = new EventEmitter();\r\n        this.waypointsMarker = [];\r\n        // Use for visible flag\r\n        this.isFirstChange = true;\r\n    }\r\n    ngOnInit() {\r\n        if (this.visible === true) {\r\n            this.directionDraw();\r\n        }\r\n    }\r\n    ngOnChanges(obj) {\r\n        /**\r\n         * When visible is false then remove the direction layer\r\n         */\r\n        if (!this.visible) {\r\n            try {\r\n                this.removeMarkers();\r\n                this.removeDirections();\r\n            }\r\n            catch (e) { }\r\n        }\r\n        else {\r\n            if (this.isFirstChange) {\r\n                /**\r\n                 * When visible is false at the first time\r\n                 */\r\n                if (typeof this.directionsRenderer === 'undefined') {\r\n                    this.directionDraw();\r\n                }\r\n                this.isFirstChange = false;\r\n                return;\r\n            }\r\n            /**\r\n             * When renderOptions are not first change then reset the display\r\n             */\r\n            if (typeof obj.renderOptions !== 'undefined') {\r\n                if (obj.renderOptions.firstChange === false) {\r\n                    this.removeMarkers();\r\n                    this.removeDirections();\r\n                }\r\n            }\r\n            this.directionDraw();\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this.destroyMarkers();\r\n        this.removeDirections();\r\n    }\r\n    /**\r\n     * This event is fired when the user creating or updating this direction\r\n     */\r\n    directionDraw() {\r\n        this.gmapsApi.getNativeMap().then(_map => {\r\n            const map = _map;\r\n            if (typeof this.directionsRenderer === 'undefined') {\r\n                this.directionsRenderer = new google.maps.DirectionsRenderer(this.renderOptions);\r\n                // @ts-ignore\r\n                this.directionsRenderer.setMap(map);\r\n                this.directionsRenderer.addListener('directions_changed', () => {\r\n                    this.onChange.emit(this.directionsRenderer.getDirections());\r\n                });\r\n            }\r\n            if (typeof this.directionsService === 'undefined') {\r\n                this.directionsService = new google.maps.DirectionsService();\r\n            }\r\n            if (typeof this.panel === 'undefined') {\r\n                // @ts-ignore\r\n                this.directionsRenderer.setPanel(null);\r\n            }\r\n            else {\r\n                this.directionsRenderer.setPanel(this.panel);\r\n            }\r\n            // Render exist direction\r\n            if (this.renderRoute) {\r\n                this.directionsRenderer.setDirections(this.renderRoute);\r\n                this.renderRoute = undefined;\r\n            }\r\n            else {\r\n                // Request new direction\r\n                this.directionsService.route({\r\n                    origin: this.origin,\r\n                    destination: this.destination,\r\n                    travelMode: this.travelMode || google.maps.TravelMode.DRIVING,\r\n                    transitOptions: this.transitOptions,\r\n                    drivingOptions: this.drivingOptions,\r\n                    waypoints: this.waypoints,\r\n                    optimizeWaypoints: this.optimizeWaypoints,\r\n                    provideRouteAlternatives: this.provideRouteAlternatives,\r\n                    avoidHighways: this.avoidHighways,\r\n                    avoidTolls: this.avoidTolls,\r\n                    avoidFerries: this.avoidFerries,\r\n                    unitSystem: this.unitSystem,\r\n                }, (response, status) => {\r\n                    this.onResponse.emit(response);\r\n                    // Emit Query Status\r\n                    this.status.emit(status);\r\n                    /**\r\n                     * DirectionsStatus\r\n                     * https://developers.google.com/maps/documentation/javascript/directions#DirectionsStatus\r\n                     */\r\n                    switch (status) {\r\n                        case google.maps.DirectionsStatus.OK:\r\n                            this.directionsRenderer.setDirections(response);\r\n                            /**\r\n                             * Emit The DirectionsResult Object\r\n                             * https://developers.google.com/maps/documentation/javascript/directions?hl=en#DirectionsResults\r\n                             */\r\n                            // Custom Markers\r\n                            if (typeof this.markerOptions !== 'undefined') {\r\n                                this.destroyMarkers();\r\n                                // Set custom markers\r\n                                const _route = response.routes[0].legs[0];\r\n                                try {\r\n                                    // Origin Marker\r\n                                    if (typeof this.markerOptions.origin !== 'undefined') {\r\n                                        this.markerOptions.origin.map = map;\r\n                                        this.markerOptions.origin.position = _route.start_location;\r\n                                        this.originMarker = this.setMarker(map, this.originMarker, this.markerOptions.origin, _route.start_address);\r\n                                        if (this.markerOptions.origin.draggable) {\r\n                                            this.originMarker.addListener('dragend', () => {\r\n                                                this.origin = this.originMarker.position;\r\n                                                this.directionDraw();\r\n                                                this.originDrag.emit(this.origin);\r\n                                            });\r\n                                        }\r\n                                    }\r\n                                    // Destination Marker\r\n                                    if (typeof this.markerOptions.destination !== 'undefined') {\r\n                                        this.markerOptions.destination.map = map;\r\n                                        this.markerOptions.destination.position = _route.end_location;\r\n                                        this.destinationMarker = this.setMarker(map, this.destinationMarker, this.markerOptions.destination, _route.end_address);\r\n                                        if (this.markerOptions.destination.draggable) {\r\n                                            this.destinationMarker.addListener('dragend', () => {\r\n                                                this.destination = this.destinationMarker.position;\r\n                                                this.directionDraw();\r\n                                                this.destinationDrag.emit(this.destination);\r\n                                            });\r\n                                        }\r\n                                    }\r\n                                    // Waypoints Marker\r\n                                    if (typeof this.markerOptions.waypoints !== 'undefined') {\r\n                                        this.waypoints.forEach((waypoint, index) => {\r\n                                            // If waypoints are not array then set all the same\r\n                                            if (!Array.isArray(this.markerOptions.waypoints)) {\r\n                                                this.markerOptions.waypoints.map = map;\r\n                                                this.markerOptions.waypoints.position = _route.via_waypoints[index];\r\n                                                this.waypointsMarker.push(this.setMarker(map, waypoint, this.markerOptions.waypoints, _route.via_waypoints[index]));\r\n                                            }\r\n                                            else {\r\n                                                this.markerOptions.waypoints[index].map = map;\r\n                                                this.markerOptions.waypoints[index].position = _route.via_waypoints[index];\r\n                                                this.waypointsMarker.push(this.setMarker(map, waypoint, this.markerOptions.waypoints[index], _route.via_waypoints[index]));\r\n                                            }\r\n                                        }); // End forEach\r\n                                    }\r\n                                }\r\n                                catch (err) {\r\n                                    console.error('MarkerOptions error.', err);\r\n                                }\r\n                            }\r\n                            break;\r\n                        case google.maps.DirectionsStatus.OVER_QUERY_LIMIT:\r\n                            console.warn('The webpage has sent too many requests within the allowed time period.');\r\n                            break;\r\n                        default:\r\n                            // console.warn(status);\r\n                            break;\r\n                    } // End switch\r\n                });\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Custom Origin and Destination Icon\r\n     * @param map map\r\n     * @param marker marker\r\n     * @param markerOpts properties\r\n     * @param content marker's infowindow content\r\n     * @returns new marker\r\n     * @memberof AgmDirection\r\n     */\r\n    setMarker(map, marker, markerOpts, content) {\r\n        if (typeof this.infoWindow === 'undefined') {\r\n            this.infoWindow = new google.maps.InfoWindow();\r\n            this.sendInfoWindow.emit(this.infoWindow);\r\n        }\r\n        marker = new google.maps.Marker(markerOpts);\r\n        // https://developers.google.com/maps/documentation/javascript/reference/marker?hl=zh-tw#MarkerOptions.clickable\r\n        if (marker.getClickable()) {\r\n            marker.addListener('click', () => {\r\n                const infowindoContent = typeof markerOpts.infoWindow === 'undefined' ? content : markerOpts.infoWindow;\r\n                this.infoWindow.setContent(infowindoContent);\r\n                this.infoWindow.open(map, marker);\r\n            });\r\n        }\r\n        return marker;\r\n    }\r\n    /**\r\n     * This event is fired when remove markers\r\n     */\r\n    removeMarkers() {\r\n        if (typeof this.originMarker !== 'undefined') {\r\n            this.originMarker.setMap(null);\r\n        }\r\n        if (typeof this.destinationMarker !== 'undefined') {\r\n            this.destinationMarker.setMap(null);\r\n        }\r\n        this.waypointsMarker.forEach((w) => {\r\n            if (typeof w !== 'undefined') {\r\n                w.setMap(null);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * This event is fired when remove directions\r\n     */\r\n    removeDirections() {\r\n        if (this.directionsRenderer !== undefined) {\r\n            // @ts-ignore\r\n            this.directionsRenderer.setPanel(null);\r\n            this.directionsRenderer.setMap(null);\r\n            // @ts-ignore\r\n            this.directionsRenderer = undefined;\r\n        }\r\n    }\r\n    /**\r\n     * This event is fired when destroy markers\r\n     */\r\n    destroyMarkers() {\r\n        // Remove origin markers\r\n        try {\r\n            if (typeof this.originMarker !== 'undefined') {\r\n                google.maps.event.clearListeners(this.originMarker, 'click');\r\n                if (this.markerOptions.origin.draggable) {\r\n                    google.maps.event.clearListeners(this.originMarker, 'dragend');\r\n                }\r\n            }\r\n            if (typeof this.destinationMarker !== 'undefined') {\r\n                google.maps.event.clearListeners(this.destinationMarker, 'click');\r\n                if (this.markerOptions.origin.draggable) {\r\n                    google.maps.event.clearListeners(this.destinationMarker, 'dragend');\r\n                }\r\n            }\r\n            this.waypointsMarker.forEach((w) => {\r\n                if (typeof w !== 'undefined') {\r\n                    google.maps.event.clearListeners(w, 'click');\r\n                }\r\n            });\r\n            this.removeMarkers();\r\n        }\r\n        catch (err) {\r\n            console.error('Can not reset custom marker.', err);\r\n        }\r\n    }\r\n}\nAgmDirection.ɵfac = function AgmDirection_Factory(t) { return new (t || AgmDirection)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.GoogleMapsAPIWrapper)); };\nAgmDirection.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AgmDirection, selectors: [[\"agm-direction\"]], inputs: { waypoints: \"waypoints\", optimizeWaypoints: \"optimizeWaypoints\", provideRouteAlternatives: \"provideRouteAlternatives\", avoidHighways: \"avoidHighways\", avoidTolls: \"avoidTolls\", avoidFerries: \"avoidFerries\", visible: \"visible\", renderRoute: \"renderRoute\", origin: \"origin\", destination: \"destination\", infoWindow: \"infoWindow\", travelMode: \"travelMode\", transitOptions: \"transitOptions\", drivingOptions: \"drivingOptions\", unitSystem: \"unitSystem\", renderOptions: \"renderOptions\", panel: \"panel\", markerOptions: \"markerOptions\" }, outputs: { onChange: \"onChange\", onResponse: \"onResponse\", sendInfoWindow: \"sendInfoWindow\", status: \"status\", originDrag: \"originDrag\", destinationDrag: \"destinationDrag\" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\r\nAgmDirection.ctorParameters = () => [\r\n    { type: GoogleMapsAPIWrapper }\r\n];\r\nAgmDirection.propDecorators = {\r\n    origin: [{ type: Input }],\r\n    destination: [{ type: Input }],\r\n    travelMode: [{ type: Input }],\r\n    transitOptions: [{ type: Input }],\r\n    drivingOptions: [{ type: Input }],\r\n    waypoints: [{ type: Input }],\r\n    optimizeWaypoints: [{ type: Input }],\r\n    provideRouteAlternatives: [{ type: Input }],\r\n    avoidHighways: [{ type: Input }],\r\n    avoidTolls: [{ type: Input }],\r\n    avoidFerries: [{ type: Input }],\r\n    unitSystem: [{ type: Input }],\r\n    renderOptions: [{ type: Input }],\r\n    panel: [{ type: Input }],\r\n    markerOptions: [{ type: Input }],\r\n    infoWindow: [{ type: Input }],\r\n    visible: [{ type: Input }],\r\n    renderRoute: [{ type: Input }],\r\n    onChange: [{ type: Output }],\r\n    onResponse: [{ type: Output }],\r\n    sendInfoWindow: [{ type: Output }],\r\n    status: [{ type: Output }],\r\n    originDrag: [{ type: Output }],\r\n    destinationDrag: [{ type: Output }]\r\n};\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AgmDirection, [{\n        type: Directive,\n        args: [{\n                selector: 'agm-direction'\n            }]\n    }], function () { return [{ type: ɵngcc1.GoogleMapsAPIWrapper }]; }, { waypoints: [{\n            type: Input\n        }], optimizeWaypoints: [{\n            type: Input\n        }], provideRouteAlternatives: [{\n            type: Input\n        }], avoidHighways: [{\n            type: Input\n        }], avoidTolls: [{\n            type: Input\n        }], avoidFerries: [{\n            type: Input\n        }], visible: [{\n            type: Input\n        }], onChange: [{\n            type: Output\n        }], onResponse: [{\n            type: Output\n        }], sendInfoWindow: [{\n            type: Output\n        }], status: [{\n            type: Output\n        }], originDrag: [{\n            type: Output\n        }], destinationDrag: [{\n            type: Output\n        }], renderRoute: [{\n            type: Input\n        }], origin: [{\n            type: Input\n        }], destination: [{\n            type: Input\n        }], infoWindow: [{\n            type: Input\n        }], travelMode: [{\n            type: Input\n        }], transitOptions: [{\n            type: Input\n        }], drivingOptions: [{\n            type: Input\n        }], unitSystem: [{\n            type: Input\n        }], renderOptions: [{\n            type: Input\n        }], panel: [{\n            type: Input\n        }], markerOptions: [{\n            type: Input\n        }] }); })();\n\nclass AgmDirectionModule {\r\n    static forRoot() {\r\n        return {\r\n            ngModule: AgmDirectionModule,\r\n        };\r\n    }\r\n    static forChild() {\r\n        return {\r\n            ngModule: AgmDirectionModule,\r\n        };\r\n    }\r\n}\nAgmDirectionModule.ɵfac = function AgmDirectionModule_Factory(t) { return new (t || AgmDirectionModule)(); };\nAgmDirectionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: AgmDirectionModule });\nAgmDirectionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(AgmDirectionModule, { declarations: [AgmDirection], exports: [AgmDirection] }); })();\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AgmDirectionModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [\n                    AgmDirection,\n                ],\n                exports: [\n                    AgmDirection,\n                ]\n            }]\n    }], null, null); })();\n\n// Public classes.\n\n/**\r\n * Angular library starter\r\n * Build an Angular library compatible with AoT compilation & Tree shaking like an official package\r\n * Copyright Roberto Simonetti\r\n * MIT license\r\n * https://github.com/robisim74/angular-library-starter\r\n */\r\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AgmDirection, AgmDirectionModule };\n\n//# sourceMappingURL=agm-direction.js.map"],"sourceRoot":"webpack:///"}