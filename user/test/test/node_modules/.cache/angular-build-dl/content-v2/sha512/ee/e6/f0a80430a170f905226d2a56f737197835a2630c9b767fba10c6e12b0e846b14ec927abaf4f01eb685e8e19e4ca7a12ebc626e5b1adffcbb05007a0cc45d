(function () {
  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

  (window["webpackJsonp"] = window["webpackJsonp"] || []).push([["default~pages-cart-cart-module~pages-home-home-module~pages-track-track-module"], {
    /***/
    "IZFd":
    /*!***************************************************************************!*\
      !*** ./node_modules/agm-direction/__ivy_ngcc__/fesm2015/agm-direction.js ***!
      \***************************************************************************/

    /*! exports provided: AgmDirection, AgmDirectionModule */

    /***/
    function IZFd(module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "AgmDirection", function () {
        return AgmDirection;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "AgmDirectionModule", function () {
        return AgmDirectionModule;
      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      "fXoL");
      /* harmony import */


      var _agm_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @agm/core */
      "pxUr");
      /**
       * @license agm-direction
       * MIT license
       */


      var AgmDirection = /*#__PURE__*/function () {
        function AgmDirection(gmapsApi) {
          _classCallCheck(this, AgmDirection);

          this.gmapsApi = gmapsApi;
          this.waypoints = [];
          this.optimizeWaypoints = true;
          this.provideRouteAlternatives = false;
          this.avoidHighways = false;
          this.avoidTolls = false;
          this.avoidFerries = false; // Remove or draw direction

          this.visible = true; // Direction change event handler

          this.onChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"](); // Direction response for the new request

          this.onResponse = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"](); // Send a custom infowindow

          this.sendInfoWindow = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"](); // Status of Directions Query (google.maps.DirectionsStatus.OVER_QUERY_LIMIT)

          this.status = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"](); // Marker drag event handler

          this.originDrag = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
          this.destinationDrag = new _angular_core__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
          this.waypointsMarker = []; // Use for visible flag

          this.isFirstChange = true;
        }

        _createClass(AgmDirection, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            if (this.visible === true) {
              this.directionDraw();
            }
          }
        }, {
          key: "ngOnChanges",
          value: function ngOnChanges(obj) {
            /**
             * When visible is false then remove the direction layer
             */
            if (!this.visible) {
              try {
                this.removeMarkers();
                this.removeDirections();
              } catch (e) {}
            } else {
              if (this.isFirstChange) {
                /**
                 * When visible is false at the first time
                 */
                if (typeof this.directionsRenderer === 'undefined') {
                  this.directionDraw();
                }

                this.isFirstChange = false;
                return;
              }
              /**
               * When renderOptions are not first change then reset the display
               */


              if (typeof obj.renderOptions !== 'undefined') {
                if (obj.renderOptions.firstChange === false) {
                  this.removeMarkers();
                  this.removeDirections();
                }
              }

              this.directionDraw();
            }
          }
        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this.destroyMarkers();
            this.removeDirections();
          }
          /**
           * This event is fired when the user creating or updating this direction
           */

        }, {
          key: "directionDraw",
          value: function directionDraw() {
            var _this = this;

            this.gmapsApi.getNativeMap().then(function (_map) {
              var map = _map;

              if (typeof _this.directionsRenderer === 'undefined') {
                _this.directionsRenderer = new google.maps.DirectionsRenderer(_this.renderOptions); // @ts-ignore

                _this.directionsRenderer.setMap(map);

                _this.directionsRenderer.addListener('directions_changed', function () {
                  _this.onChange.emit(_this.directionsRenderer.getDirections());
                });
              }

              if (typeof _this.directionsService === 'undefined') {
                _this.directionsService = new google.maps.DirectionsService();
              }

              if (typeof _this.panel === 'undefined') {
                // @ts-ignore
                _this.directionsRenderer.setPanel(null);
              } else {
                _this.directionsRenderer.setPanel(_this.panel);
              } // Render exist direction


              if (_this.renderRoute) {
                _this.directionsRenderer.setDirections(_this.renderRoute);

                _this.renderRoute = undefined;
              } else {
                // Request new direction
                _this.directionsService.route({
                  origin: _this.origin,
                  destination: _this.destination,
                  travelMode: _this.travelMode || google.maps.TravelMode.DRIVING,
                  transitOptions: _this.transitOptions,
                  drivingOptions: _this.drivingOptions,
                  waypoints: _this.waypoints,
                  optimizeWaypoints: _this.optimizeWaypoints,
                  provideRouteAlternatives: _this.provideRouteAlternatives,
                  avoidHighways: _this.avoidHighways,
                  avoidTolls: _this.avoidTolls,
                  avoidFerries: _this.avoidFerries,
                  unitSystem: _this.unitSystem
                }, function (response, status) {
                  _this.onResponse.emit(response); // Emit Query Status


                  _this.status.emit(status);
                  /**
                   * DirectionsStatus
                   * https://developers.google.com/maps/documentation/javascript/directions#DirectionsStatus
                   */


                  switch (status) {
                    case google.maps.DirectionsStatus.OK:
                      _this.directionsRenderer.setDirections(response);
                      /**
                       * Emit The DirectionsResult Object
                       * https://developers.google.com/maps/documentation/javascript/directions?hl=en#DirectionsResults
                       */
                      // Custom Markers


                      if (typeof _this.markerOptions !== 'undefined') {
                        _this.destroyMarkers(); // Set custom markers


                        var _route = response.routes[0].legs[0];

                        try {
                          // Origin Marker
                          if (typeof _this.markerOptions.origin !== 'undefined') {
                            _this.markerOptions.origin.map = map;
                            _this.markerOptions.origin.position = _route.start_location;
                            _this.originMarker = _this.setMarker(map, _this.originMarker, _this.markerOptions.origin, _route.start_address);

                            if (_this.markerOptions.origin.draggable) {
                              _this.originMarker.addListener('dragend', function () {
                                _this.origin = _this.originMarker.position;

                                _this.directionDraw();

                                _this.originDrag.emit(_this.origin);
                              });
                            }
                          } // Destination Marker


                          if (typeof _this.markerOptions.destination !== 'undefined') {
                            _this.markerOptions.destination.map = map;
                            _this.markerOptions.destination.position = _route.end_location;
                            _this.destinationMarker = _this.setMarker(map, _this.destinationMarker, _this.markerOptions.destination, _route.end_address);

                            if (_this.markerOptions.destination.draggable) {
                              _this.destinationMarker.addListener('dragend', function () {
                                _this.destination = _this.destinationMarker.position;

                                _this.directionDraw();

                                _this.destinationDrag.emit(_this.destination);
                              });
                            }
                          } // Waypoints Marker


                          if (typeof _this.markerOptions.waypoints !== 'undefined') {
                            _this.waypoints.forEach(function (waypoint, index) {
                              // If waypoints are not array then set all the same
                              if (!Array.isArray(_this.markerOptions.waypoints)) {
                                _this.markerOptions.waypoints.map = map;
                                _this.markerOptions.waypoints.position = _route.via_waypoints[index];

                                _this.waypointsMarker.push(_this.setMarker(map, waypoint, _this.markerOptions.waypoints, _route.via_waypoints[index]));
                              } else {
                                _this.markerOptions.waypoints[index].map = map;
                                _this.markerOptions.waypoints[index].position = _route.via_waypoints[index];

                                _this.waypointsMarker.push(_this.setMarker(map, waypoint, _this.markerOptions.waypoints[index], _route.via_waypoints[index]));
                              }
                            }); // End forEach

                          }
                        } catch (err) {
                          console.error('MarkerOptions error.', err);
                        }
                      }

                      break;

                    case google.maps.DirectionsStatus.OVER_QUERY_LIMIT:
                      console.warn('The webpage has sent too many requests within the allowed time period.');
                      break;

                    default:
                      // console.warn(status);
                      break;
                  } // End switch

                });
              }
            });
          }
          /**
           * Custom Origin and Destination Icon
           * @param map map
           * @param marker marker
           * @param markerOpts properties
           * @param content marker's infowindow content
           * @returns new marker
           * @memberof AgmDirection
           */

        }, {
          key: "setMarker",
          value: function setMarker(map, marker, markerOpts, content) {
            var _this2 = this;

            if (typeof this.infoWindow === 'undefined') {
              this.infoWindow = new google.maps.InfoWindow();
              this.sendInfoWindow.emit(this.infoWindow);
            }

            marker = new google.maps.Marker(markerOpts); // https://developers.google.com/maps/documentation/javascript/reference/marker?hl=zh-tw#MarkerOptions.clickable

            if (marker.getClickable()) {
              marker.addListener('click', function () {
                var infowindoContent = typeof markerOpts.infoWindow === 'undefined' ? content : markerOpts.infoWindow;

                _this2.infoWindow.setContent(infowindoContent);

                _this2.infoWindow.open(map, marker);
              });
            }

            return marker;
          }
          /**
           * This event is fired when remove markers
           */

        }, {
          key: "removeMarkers",
          value: function removeMarkers() {
            if (typeof this.originMarker !== 'undefined') {
              this.originMarker.setMap(null);
            }

            if (typeof this.destinationMarker !== 'undefined') {
              this.destinationMarker.setMap(null);
            }

            this.waypointsMarker.forEach(function (w) {
              if (typeof w !== 'undefined') {
                w.setMap(null);
              }
            });
          }
          /**
           * This event is fired when remove directions
           */

        }, {
          key: "removeDirections",
          value: function removeDirections() {
            if (this.directionsRenderer !== undefined) {
              // @ts-ignore
              this.directionsRenderer.setPanel(null);
              this.directionsRenderer.setMap(null); // @ts-ignore

              this.directionsRenderer = undefined;
            }
          }
          /**
           * This event is fired when destroy markers
           */

        }, {
          key: "destroyMarkers",
          value: function destroyMarkers() {
            // Remove origin markers
            try {
              if (typeof this.originMarker !== 'undefined') {
                google.maps.event.clearListeners(this.originMarker, 'click');

                if (this.markerOptions.origin.draggable) {
                  google.maps.event.clearListeners(this.originMarker, 'dragend');
                }
              }

              if (typeof this.destinationMarker !== 'undefined') {
                google.maps.event.clearListeners(this.destinationMarker, 'click');

                if (this.markerOptions.origin.draggable) {
                  google.maps.event.clearListeners(this.destinationMarker, 'dragend');
                }
              }

              this.waypointsMarker.forEach(function (w) {
                if (typeof w !== 'undefined') {
                  google.maps.event.clearListeners(w, 'click');
                }
              });
              this.removeMarkers();
            } catch (err) {
              console.error('Can not reset custom marker.', err);
            }
          }
        }]);

        return AgmDirection;
      }();

      AgmDirection.ɵfac = function AgmDirection_Factory(t) {
        return new (t || AgmDirection)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_agm_core__WEBPACK_IMPORTED_MODULE_1__["GoogleMapsAPIWrapper"]));
      };

      AgmDirection.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: AgmDirection,
        selectors: [["agm-direction"]],
        inputs: {
          waypoints: "waypoints",
          optimizeWaypoints: "optimizeWaypoints",
          provideRouteAlternatives: "provideRouteAlternatives",
          avoidHighways: "avoidHighways",
          avoidTolls: "avoidTolls",
          avoidFerries: "avoidFerries",
          visible: "visible",
          renderRoute: "renderRoute",
          origin: "origin",
          destination: "destination",
          infoWindow: "infoWindow",
          travelMode: "travelMode",
          transitOptions: "transitOptions",
          drivingOptions: "drivingOptions",
          unitSystem: "unitSystem",
          renderOptions: "renderOptions",
          panel: "panel",
          markerOptions: "markerOptions"
        },
        outputs: {
          onChange: "onChange",
          onResponse: "onResponse",
          sendInfoWindow: "sendInfoWindow",
          status: "status",
          originDrag: "originDrag",
          destinationDrag: "destinationDrag"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
      });

      AgmDirection.ctorParameters = function () {
        return [{
          type: _agm_core__WEBPACK_IMPORTED_MODULE_1__["GoogleMapsAPIWrapper"]
        }];
      };

      AgmDirection.propDecorators = {
        origin: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        destination: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        travelMode: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        transitOptions: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        drivingOptions: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        waypoints: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        optimizeWaypoints: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        provideRouteAlternatives: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        avoidHighways: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        avoidTolls: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        avoidFerries: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        unitSystem: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        renderOptions: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        panel: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        markerOptions: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        infoWindow: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        visible: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        renderRoute: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
        }],
        onChange: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        onResponse: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        sendInfoWindow: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        status: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        originDrag: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }],
        destinationDrag: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](AgmDirection, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Directive"],
          args: [{
            selector: 'agm-direction'
          }]
        }], function () {
          return [{
            type: _agm_core__WEBPACK_IMPORTED_MODULE_1__["GoogleMapsAPIWrapper"]
          }];
        }, {
          waypoints: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          optimizeWaypoints: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          provideRouteAlternatives: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          avoidHighways: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          avoidTolls: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          avoidFerries: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          visible: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          onChange: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
          }],
          onResponse: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
          }],
          sendInfoWindow: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
          }],
          status: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
          }],
          originDrag: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
          }],
          destinationDrag: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Output"]
          }],
          renderRoute: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          origin: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          destination: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          infoWindow: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          travelMode: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          transitOptions: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          drivingOptions: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          unitSystem: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          renderOptions: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          panel: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }],
          markerOptions: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["Input"]
          }]
        });
      })();

      var AgmDirectionModule = /*#__PURE__*/function () {
        function AgmDirectionModule() {
          _classCallCheck(this, AgmDirectionModule);
        }

        _createClass(AgmDirectionModule, null, [{
          key: "forRoot",
          value: function forRoot() {
            return {
              ngModule: AgmDirectionModule
            };
          }
        }, {
          key: "forChild",
          value: function forChild() {
            return {
              ngModule: AgmDirectionModule
            };
          }
        }]);

        return AgmDirectionModule;
      }();

      AgmDirectionModule.ɵfac = function AgmDirectionModule_Factory(t) {
        return new (t || AgmDirectionModule)();
      };

      AgmDirectionModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
        type: AgmDirectionModule
      });
      AgmDirectionModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](AgmDirectionModule, {
          declarations: [AgmDirection],
          exports: [AgmDirection]
        });
      })();

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](AgmDirectionModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__["NgModule"],
          args: [{
            declarations: [AgmDirection],
            exports: [AgmDirection]
          }]
        }], null, null);
      })(); // Public classes.

      /**
       * Angular library starter
       * Build an Angular library compatible with AoT compilation & Tree shaking like an official package
       * Copyright Roberto Simonetti
       * MIT license
       * https://github.com/robisim74/angular-library-starter
       */
      // This file only reexports content of the `src` folder. Keep it that way.

      /**
       * Generated bundle index. Do not edit.
       */
      //# sourceMappingURL=agm-direction.js.map

      /***/

    }
  }]);
})();
//# sourceMappingURL=default~pages-cart-cart-module~pages-home-home-module~pages-track-track-module-es5.js.map